<!DOCTYPE html>

<html lang="en" data-content_root="../">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" /><meta name="viewport" content="width=device-width, initial-scale=1" />

    <title>Sample Representation &#8212; Refl1D 0.7.7.post1533+gc6a0ac1 documentation</title>
    <link rel="stylesheet" type="text/css" href="../_static/pygments.css?v=fa44fd50" />
    <link rel="stylesheet" type="text/css" href="../_static/haiku-site.css?v=ccbba224" />
    <link rel="stylesheet" type="text/css" href="../_static/plot_directive.css" />
    <script src="../_static/documentation_options.js?v=132fb2fb"></script>
    <script src="../_static/doctools.js?v=9bcbadda"></script>
    <script src="../_static/sphinx_highlight.js?v=dc90522c"></script>
    <script async="async" src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" />
    <link rel="next" title="Experiment" href="experiment.html" />
    <link rel="prev" title="Materials" href="materials.html" /> 
  </head><body>
      <div class="header" role="banner"><h1 class="heading"><a href="../index.html">
          <span>Refl1D 0.7.7.post1533+gc6a0ac1 documentation</span></a></h1>
        <h2 class="heading"><span>Sample Representation</span></h2>
      </div>
      <div class="topnav" role="navigation" aria-label="Top">
      
        <p>
        «&#160;&#160;<a href="materials.html">Materials</a>
        &#160;&#160;::&#160;&#160;
        <a class="uplink" href="../index.html">Contents</a>
        &#160;&#160;::&#160;&#160;
        <a href="experiment.html">Experiment</a>&#160;&#160;»
        </p>

      </div>
      <div class="content" role="main">
        
        
  <section id="sample-representation">
<span id="sample-guide"></span><h1>Sample Representation<a class="headerlink" href="#sample-representation" title="Link to this heading">¶</a></h1>
<nav class="contents local" id="contents">
<ul class="simple">
<li><p><a class="reference internal" href="#stacks" id="id1">Stacks</a></p></li>
<li><p><a class="reference internal" href="#multilayers" id="id2">Multilayers</a></p></li>
<li><p><a class="reference internal" href="#interfaces" id="id3">Interfaces</a></p></li>
<li><p><a class="reference internal" href="#slabs" id="id4">Slabs</a></p></li>
<li><p><a class="reference internal" href="#magnetic-layers" id="id5">Magnetic layers</a></p></li>
<li><p><a class="reference internal" href="#polymer-layers" id="id6">Polymer layers</a></p></li>
<li><p><a class="reference internal" href="#functional-layers" id="id7">Functional layers</a></p></li>
<li><p><a class="reference internal" href="#freeform-layers" id="id8">Freeform layers</a></p>
<ul>
<li><p><a class="reference internal" href="#comparison-of-models" id="id9">Comparison of models</a></p></li>
<li><p><a class="reference internal" href="#future-work" id="id10">Future work</a></p></li>
</ul>
</li>
<li><p><a class="reference internal" href="#subclassing-layer" id="id11">Subclassing Layer</a></p></li>
</ul>
</nav>
<section id="stacks">
<h2><a class="toc-backref" href="#id1" role="doc-backlink">Stacks</a><a class="headerlink" href="#stacks" title="Link to this heading">¶</a></h2>
<p>Reflectometry samples consist of 1-D stacks of layers joined by error
function interfaces. The layers themselves may be uniform slabs, or
the scattering density may vary with depth in the layer.  The first
layer in the stack is the substrate and the final layer is the surface.
Surface and substrate are assumed to be semi-infinite, with any thickness
ignored.</p>
</section>
<section id="multilayers">
<h2><a class="toc-backref" href="#id2" role="doc-backlink">Multilayers</a><a class="headerlink" href="#multilayers" title="Link to this heading">¶</a></h2>
</section>
<section id="interfaces">
<h2><a class="toc-backref" href="#id3" role="doc-backlink">Interfaces</a><a class="headerlink" href="#interfaces" title="Link to this heading">¶</a></h2>
<p>The interface between layers is assumed to smoothly follow and
error function profile to blend the layer above with the layer below.
The interface value is the 1-<span class="math notranslate nohighlight">\(\sigma\)</span> gaussian roughness.
Adjacent flat layers with zero interface will act like a step function,
while positive values will introduce blending between the layers.</p>
<p>Blending is usually done with the Nevot-Croce formalism, which scales
the index of refraction between two layers by <span class="math notranslate nohighlight">\(\exp(-2 k_n k_{n+1} \sigma^2)\)</span>.
We show both a step function profile for the interface, as well as the
blended interface.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>The blended interface representation is limited to the neighbouring
layers, and is not an accurate representation of the effective
reflectivity profile when the interface value is large relative to
the thickness of the layer.</p>
</div>
<p>We will have a mechanism to force the use of the blended profile for
direct calculation of the interfaces rather than using the interface
scale factor.</p>
</section>
<section id="slabs">
<h2><a class="toc-backref" href="#id4" role="doc-backlink">Slabs</a><a class="headerlink" href="#slabs" title="Link to this heading">¶</a></h2>
<p>Materials can be stacked as slabs, with a thickness for each layer and
roughness at the top of each layer.  Because this is such a common
operation, there is special syntax to do it, using ‘|’ as the layer
separator and <cite>()</cite> to specify thickness and interface.  For example,
the following is a 30 Å gold layer on top of silicon, with a
silicon:gold interface of 5 Å and a gold:air interface of 2 Å:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="o">&gt;&gt;</span> <span class="kn">from</span> <span class="nn">refl1d</span> <span class="kn">import</span> <span class="o">*</span>
<span class="o">&gt;&gt;</span> <span class="n">sample</span> <span class="o">=</span> <span class="n">silicon</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">5</span><span class="p">)</span> <span class="o">|</span> <span class="n">gold</span><span class="p">(</span><span class="mi">30</span><span class="p">,</span><span class="mi">2</span><span class="p">)</span> <span class="o">|</span> <span class="n">air</span>
<span class="o">&gt;&gt;</span> <span class="nb">print</span> <span class="n">sample</span>
<span class="n">Si</span> <span class="o">|</span> <span class="n">Au</span><span class="p">(</span><span class="mi">30</span><span class="p">)</span> <span class="o">|</span> <span class="n">air</span>
</pre></div>
</div>
<p>Individual layers and stacks can be used in multiple models, with all
parameters shared except those that are explicitly made separate.  The
syntax for doing so is similar to that for lists.  For example, the
following defines two samples, one with Si+Au/30+air and the other with
Si+Au/30+alkanethiol/10+air, with the silicon/gold layers shared:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="o">&gt;&gt;</span> <span class="n">alkane_thiol</span> <span class="o">=</span> <span class="n">Material</span><span class="p">(</span><span class="s1">&#39;C2H4OHS&#39;</span><span class="p">,</span><span class="n">bulk_density</span><span class="o">=</span><span class="mf">0.8</span><span class="p">,</span><span class="n">name</span><span class="o">=</span><span class="s1">&#39;thiol&#39;</span><span class="p">)</span>
<span class="o">&gt;&gt;</span> <span class="n">sample1</span> <span class="o">=</span> <span class="n">silicon</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">5</span><span class="p">)</span> <span class="o">|</span> <span class="n">gold</span><span class="p">(</span><span class="mi">30</span><span class="p">,</span><span class="mi">2</span><span class="p">)</span> <span class="o">|</span> <span class="n">air</span>
<span class="o">&gt;&gt;</span> <span class="n">sample2</span> <span class="o">=</span> <span class="n">sample1</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">|</span> <span class="n">alkane_thiol</span><span class="p">(</span><span class="mi">10</span><span class="p">,</span><span class="mi">3</span><span class="p">)</span> <span class="o">|</span> <span class="n">air</span>
<span class="o">&gt;&gt;</span> <span class="nb">print</span> <span class="n">sample2</span>
<span class="n">Si</span> <span class="o">|</span> <span class="n">Au</span><span class="p">(</span><span class="mi">30</span><span class="p">)</span> <span class="o">|</span> <span class="n">thiol</span><span class="p">(</span><span class="mi">10</span><span class="p">)</span> <span class="o">|</span> <span class="n">air</span>
</pre></div>
</div>
<p>Stacks can be repeated using a simple multiply operation.  For example,
the following gives a cobalt/copper multilayer on silicon:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="o">&gt;&gt;</span> <span class="n">Cu</span> <span class="o">=</span> <span class="n">Material</span><span class="p">(</span><span class="s1">&#39;Cu&#39;</span><span class="p">)</span>
<span class="o">&gt;&gt;</span> <span class="n">Co</span> <span class="o">=</span> <span class="n">Material</span><span class="p">(</span><span class="s1">&#39;Co&#39;</span><span class="p">)</span>
<span class="o">&gt;&gt;</span> <span class="n">sample</span> <span class="o">=</span> <span class="n">Si</span> <span class="o">|</span> <span class="p">[</span><span class="n">Co</span><span class="p">(</span><span class="mi">30</span><span class="p">)</span> <span class="o">|</span> <span class="n">Cu</span><span class="p">(</span><span class="mi">10</span><span class="p">)]</span><span class="o">*</span><span class="mi">20</span> <span class="o">|</span> <span class="n">Co</span><span class="p">(</span><span class="mi">30</span><span class="p">)</span> <span class="o">|</span> <span class="n">air</span>
<span class="o">&gt;&gt;</span> <span class="nb">print</span> <span class="n">sample</span>
<span class="n">Si</span> <span class="o">|</span> <span class="p">[</span><span class="n">Co</span><span class="p">(</span><span class="mi">30</span><span class="p">)</span> <span class="o">|</span> <span class="n">Cu</span><span class="p">(</span><span class="mi">10</span><span class="p">)]</span><span class="o">*</span><span class="mi">20</span> <span class="o">|</span> <span class="n">Co</span><span class="p">(</span><span class="mi">30</span><span class="p">)</span> <span class="o">|</span> <span class="n">air</span>
</pre></div>
</div>
<p>Multiple repeat sections can be included, and repeats can contain repeats.
Even freeform layers can be repeated.  By default the interface between
the repeats is the same as the interface between the repeats and the cap.
The cap interface can be set explicitly.  See <code class="xref py py-class docutils literal notranslate"><span class="pre">model.Repeat</span></code> for
details.</p>
</section>
<section id="magnetic-layers">
<h2><a class="toc-backref" href="#id5" role="doc-backlink">Magnetic layers</a><a class="headerlink" href="#magnetic-layers" title="Link to this heading">¶</a></h2>
</section>
<section id="polymer-layers">
<h2><a class="toc-backref" href="#id6" role="doc-backlink">Polymer layers</a><a class="headerlink" href="#polymer-layers" title="Link to this heading">¶</a></h2>
</section>
<section id="functional-layers">
<h2><a class="toc-backref" href="#id7" role="doc-backlink">Functional layers</a><a class="headerlink" href="#functional-layers" title="Link to this heading">¶</a></h2>
</section>
<section id="freeform-layers">
<h2><a class="toc-backref" href="#id8" role="doc-backlink">Freeform layers</a><a class="headerlink" href="#freeform-layers" title="Link to this heading">¶</a></h2>
<p>Freeform profiles allow us to adjust the shape of the depth profile using
control parameters.  The profile can directly represent the scattering
length density as a function of depth (a FreeLayer), or the relative
fraction of one material and another (a FreeInterface).  With a freeform
interface you can simultaneously fit two systems which should share the
same volume profile but whose materials have different scattering length
densities.  For example, a polymer in deuterated and undeuterated solvents
can be simultaneously fit with freeform profiles.</p>
<p>We have multiple representations for freeform profiles, each with its
own strengths and weaknesses:</p>
<blockquote>
<div><ul class="simple">
<li><p><a class="reference external" href="http://en.wikipedia.org/wiki/Monotone_cubic_interpolation">monotone cubic interpolation</a>
(<a class="reference internal" href="../refl1d.mono.html#module-refl1d.mono" title="refl1d.mono"><code class="xref py py-mod docutils literal notranslate"><span class="pre">refl1d.mono</span></code></a>)</p></li>
<li><p><a class="reference external" href="http://en.wikipedia.org/wiki/B-spline">parameteric B-splines</a>
(<a class="reference internal" href="../refl1d.freeform.html#module-refl1d.freeform" title="refl1d.freeform"><code class="xref py py-mod docutils literal notranslate"><span class="pre">refl1d.freeform</span></code></a>)</p></li>
<li><dl class="simple">
<dt><a class="reference external" href="http://en.wikipedia.org/wiki/Chebyshev_polynomials">Chebyshev interpolating polynomials</a></dt><dd><p>(<a class="reference internal" href="../refl1d.cheby.html#module-refl1d.cheby" title="refl1d.cheby"><code class="xref py py-mod docutils literal notranslate"><span class="pre">refl1d.cheby</span></code></a>)</p>
</dd>
</dl>
</li>
</ul>
</div></blockquote>
<p>At present, monotone cubic interpolation is the most developed, but work
on all representations is in flux.  In particular not every representation
supports all features, and the programming interface may vary. See the
documentation for the individual models for details.</p>
<section id="comparison-of-models">
<h3><a class="toc-backref" href="#id9" role="doc-backlink">Comparison of models</a><a class="headerlink" href="#comparison-of-models" title="Link to this heading">¶</a></h3>
<p>There are a number of issues surrounding the choice of model.</p>
<ul>
<li><p>How easy is it to bound the profile values</p>
<p>If the you can put reasonable bounds on the control points, then the
user can bring to bear prior information to limit the search space.
For example, it is common to add an unknown silicon-oxide profile
to the surface of silicon, with SLD varying between the values for
Si and SiO<sub>2</sub>.</p>
</li>
<li><p>How easy is it to edit the profile interactively</p>
<p>Given a representation of the freeform layer, we want to be able to
plot control points that you can drag in order to change the shape
of the profile.</p>
</li>
<li><p>Is the profile stable or does it oscillate wildly</p>
<p>Many systems are best described by smoothly varying density profiles.
If the profile oscillates wildly it makes the search for optimal
parameters more difficult.</p>
</li>
<li><p>Can you change the order of interpolation and preserve the profile</p>
<p>While the current code does not support it, we would like to be
able to select the freeform profile order automatically, using the
minimum order we can to achieve <span class="math notranslate nohighlight">\(\chi^2 = 1\)</span>, and rejecting profiles
which overfit the data.  For now this is done by hand, performing
fits with different orders independently, but there are likely to
be speed gains by first fitting coarse models with low Q then adding
detail to the profile while adding additional Q values.</p>
</li>
<li><p>Is the representation unique?  Are the control parameters strongly
correlated?</p>
<p>Fitting and uncertainty analysis benefit from unique solutions.  If
the model representation is matched by a family of parameters it is
more difficult to interpret the results of the uncertainty analysis
or to get convergence from the parameter refinement engine.</p>
</li>
</ul>
<p>Monotone cubic interpolation is the easiest to control.  The value of the
interpolating polynomial lies mostly within the range of the control
points, and the profile goes through the control points.  This means
you can set up bounds on the control parameters that limit the profile
to a certain range of scattering length densities in a region of the
profile.  It also leads to a very intuitive interactive profile editor
since the control points can be moved directly on profile view.  However,
although the profile is <span class="math notranslate nohighlight">\(C^1\)</span> smooth everywhere, the <span class="math notranslate nohighlight">\(C^2\)</span> transitions
can be abrupt at the control points.  Better algorithms for selecting the
gradient exist but have not been implemented, so this may improve in
the future.</p>
<p>Parametric B-splines are commonly used in computer graphics because they
create pleasing curves.  The interpolating polynomial lies within the
convex hull of the control points.  Unfortunately the distance between the
curve and the control point can be large, and this makes it difficult
to set reasonable bounds on the values of the control points.  One can
reformulate the interpolation so that control points lie on the curve
and still preserve the property of pleasing curves, but this can lead
to wild oscillations in the profile when the control points become too
close together.  While the natural representation can be used in an
interactive profile editor, the fact that the control points are sometimes
far away from the profile makes this inconvenient.  The complementary
representation is used in programs such as Microsoft Excel, with the
control point directly on the curve and a secondary control point to
adjust the slope at that control point.</p>
<p>Chebyshev interpolating polynomials are a near optimal representation
for an function over an interval with respect to the maximum norm.  The
interpolating polynomial is a weighted sum <span class="math notranslate nohighlight">\(\sigma_{i=0}^n c_i T_i(z)\)</span>
of the Chebyshev basis polynomials <span class="math notranslate nohighlight">\(T_i\)</span> with Chebyshev coefficients <span class="math notranslate nohighlight">\(c_i\)</span>.
One very interesting property is that the lower order coefficients remain
the same has higher order interpolation polynomials are constructed.
This makes the Chebyshev polynomials very interesting candidates for
a freeform profile fitter which selects the order of the profile as
part of the fit.  Chebyshev interpolating polynomials can exhibit
wild oscillations if the coefficients become large, so the smoothness
can be somewhat controlled by limiting these higher values, but we have
not explored this in depth. The Chebyshev coefficient values are not
directly tied to the profile, so there is no intuitive way to directly
control the coefficients in an interactive editor. The complementary
representation uses the profile value at the chebyshev nodes for
specific positions <span class="math notranslate nohighlight">\(z_i\)</span> on the profile.  This representation is much
more natural for an interactive editor, but some choices of control
values will lead to wild oscillations between the nodes.  Similarly
the complementary representation is unsuitable as a representation
for the fittable parameters since the bounds on the parameters do
not directly limit the range of possible values of the profile.</p>
</section>
<section id="future-work">
<h3><a class="toc-backref" href="#id10" role="doc-backlink">Future work</a><a class="headerlink" href="#future-work" title="Link to this heading">¶</a></h3>
<p>We only have polynomial spline representations for our profiles.  Similar
profiles could be constructed from different basis functions such as
wavelets, the idea being to find a multiscale representation of your
profile and use model selection techniques to determine the most coarse
grained representation that matches your data.</p>
<p>Totally freeform representations as separately controlled microslab
heights would also be interesting in the context of a maximum entropy
fitting engine: find the smoothest profile which matches the data, for
some definition of ‘smooth’.  Some possible smoothness measures are the
mean squared distance from zero, the number of sign changes in the second
derivative, the sum of the absolute value of the first derivative, the
maximum flat region, the minimum number of flat slabs, etc.  Given that
reflectometry inversion is not unique, the smoothness measure must
correspond to the likelihood of finding the system in that particularly
state:  that is, don’t expect your sample to show zebra stripes unless
you are on an African safari or visiting a zoo.</p>
</section>
</section>
<section id="subclassing-layer">
<span id="new-layers"></span><h2><a class="toc-backref" href="#id11" role="doc-backlink">Subclassing Layer</a><a class="headerlink" href="#subclassing-layer" title="Link to this heading">¶</a></h2>
</section>
</section>


      </div>
      <div class="bottomnav" role="navigation" aria-label="Bottom">
      
        <p>
        «&#160;&#160;<a href="materials.html">Materials</a>
        &#160;&#160;::&#160;&#160;
        <a class="uplink" href="../index.html">Contents</a>
        &#160;&#160;::&#160;&#160;
        <a href="experiment.html">Experiment</a>&#160;&#160;»
        </p>

      </div>

    <div class="footer" role="contentinfo">
      Created using <a href="https://www.sphinx-doc.org/">Sphinx</a> 8.1.3.
    </div>
  </body>
</html>