<!DOCTYPE html>

<html lang="en" data-content_root="../../">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>bumps.errplot &#8212; Refl1D 0.7.7.post1533+gc6a0ac1 documentation</title>
    <link rel="stylesheet" type="text/css" href="../../_static/pygments.css?v=fa44fd50" />
    <link rel="stylesheet" type="text/css" href="../../_static/haiku-site.css?v=ccbba224" />
    <link rel="stylesheet" type="text/css" href="../../_static/plot_directive.css" />
    <script src="../../_static/documentation_options.js?v=132fb2fb"></script>
    <script src="../../_static/doctools.js?v=9bcbadda"></script>
    <script src="../../_static/sphinx_highlight.js?v=dc90522c"></script>
    <link rel="index" title="Index" href="../../genindex.html" />
    <link rel="search" title="Search" href="../../search.html" /> 
  </head><body>
      <div class="header" role="banner"><h1 class="heading"><a href="../../index.html">
          <span>Refl1D 0.7.7.post1533+gc6a0ac1 documentation</span></a></h1>
        <h2 class="heading"><span>bumps.errplot</span></h2>
      </div>
      <div class="topnav" role="navigation" aria-label="Top">
      
        <p>
        <a class="uplink" href="../../index.html">Contents</a>
        </p>

      </div>
      <div class="content" role="main">
        
        
  <h1>Source code for bumps.errplot</h1><div class="highlight"><pre>
<span></span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">Estimate model uncertainty from random sample.</span>

<span class="sd">MCMC uncertainty analysis gives the uncertainty on the model parameters</span>
<span class="sd">rather than the model itself.  For example, when fitting a line to a set</span>
<span class="sd">of data, the uncertainty on the slope and the intercept does not directly</span>
<span class="sd">give you the uncertainty in the expected value of *y* for a given value</span>
<span class="sd">of *x*.</span>

<span class="sd">The routines in bumps.errplot allow you to generate confidence intervals</span>
<span class="sd">on  the model using a random sample of MCMC parameters.  After calculating</span>
<span class="sd">the model *y* values for each sample, one can generate 68% and 95% contours</span>
<span class="sd">for a set of sampling points *x*.  This can apply even to models which</span>
<span class="sd">are not directly measured.  For example, in scattering inverse problems</span>
<span class="sd">the scattered intensity is the value measured, but the fitting parameters</span>
<span class="sd">describe the real space model that is being probed.  It is the uncertainty</span>
<span class="sd">in the real space model that is of primary interest.</span>

<span class="sd">Since bumps knows only the probability of seeing the measured value given</span>
<span class="sd">the input parameters, it is up to the model itself to calculate and display</span>
<span class="sd">the confidence intervals on the model and the expected values for the data</span>
<span class="sd">points.  This is done using the :mod:`bumps.plugin` architecture, so</span>
<span class="sd">application writers can provide the appropriate functions for their data</span>
<span class="sd">types.  Eventually this capability will move to the model definition so</span>
<span class="sd">that different types of models can be processed in the same fit.</span>

<span class="sd">For a completed MCMC run, four steps are required:</span>

<span class="sd">#. reload the fitting problem and the MCMC state</span>
<span class="sd">#. select a set of sample points</span>
<span class="sd">#. evaluate model confidence intervals from sample points</span>
<span class="sd">#. show model confidence intervals</span>

<span class="sd">:func:`reload_errors` performs steps 1, 2 and 3, returning *errs*.</span>
<span class="sd">If the fitting problem and the MCMC state are already loaded, then use</span>
<span class="sd">:func:`calc_errors_from_state` to perform steps 2 and 3, returning *errs*.</span>
<span class="sd">If alternative sampling is desired, then use :func:`calc_errors` on a</span>
<span class="sd">given set of points to perform step 3, returning *errs*.  Once *errs* has</span>
<span class="sd">been calculated and returned by one of these methods, call</span>
<span class="sd">:func:`show_errors` to perform step 4.</span>
<span class="sd">&quot;&quot;&quot;</span>
<span class="n">__all__</span> <span class="o">=</span> <span class="p">[</span><span class="s2">&quot;reload_errors&quot;</span><span class="p">,</span> <span class="s2">&quot;calc_errors_from_state&quot;</span><span class="p">,</span> <span class="s2">&quot;calc_errors&quot;</span><span class="p">,</span>
           <span class="s2">&quot;show_errors&quot;</span><span class="p">]</span>
<span class="kn">import</span> <span class="nn">os</span>
<span class="kn">import</span> <span class="nn">traceback</span>
<span class="kn">import</span> <span class="nn">logging</span>

<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>

<span class="kn">from</span> <span class="nn">.dream.state</span> <span class="kn">import</span> <span class="n">load_state</span>
<span class="kn">from</span> <span class="nn">.</span> <span class="kn">import</span> <span class="n">plugin</span>
<span class="kn">from</span> <span class="nn">.cli</span> <span class="kn">import</span> <span class="n">load_model</span><span class="p">,</span> <span class="n">load_best</span>

<div class="viewcode-block" id="reload_errors">
<a class="viewcode-back" href="../../refl1d.errors.html#refl1d.errors.reload_errors">[docs]</a>
<span class="k">def</span> <span class="nf">reload_errors</span><span class="p">(</span><span class="n">model</span><span class="p">,</span> <span class="n">store</span><span class="p">,</span> <span class="n">nshown</span><span class="o">=</span><span class="mi">50</span><span class="p">,</span> <span class="n">random</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Reload the MCMC state and compute the model confidence intervals.</span>

<span class="sd">    The loaded error data is a sample from the fit space according to the</span>
<span class="sd">    fit parameter uncertainty.  This is a subset of the samples returned</span>
<span class="sd">    by the DREAM MCMC sampling process.</span>

<span class="sd">    *model* is the name of the model python file</span>

<span class="sd">    *store* is the name of the store directory containing the dream results</span>

<span class="sd">    *nshown* and *random* are as for :func:`calc_errors_from_state`.</span>

<span class="sd">    Returns *errs* for :func:`show_errors`.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">problem</span> <span class="o">=</span> <span class="n">load_model</span><span class="p">(</span><span class="n">model</span><span class="p">)</span>
    <span class="n">load_best</span><span class="p">(</span><span class="n">problem</span><span class="p">,</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">store</span><span class="p">,</span> <span class="n">problem</span><span class="o">.</span><span class="n">name</span> <span class="o">+</span> <span class="s2">&quot;.par&quot;</span><span class="p">))</span>
    <span class="n">state</span> <span class="o">=</span> <span class="n">load_state</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">store</span><span class="p">,</span> <span class="n">problem</span><span class="o">.</span><span class="n">name</span><span class="p">))</span>
    <span class="n">state</span><span class="o">.</span><span class="n">mark_outliers</span><span class="p">()</span>
    <span class="k">return</span> <span class="n">calc_errors_from_state</span><span class="p">(</span>
        <span class="n">problem</span><span class="p">,</span> <span class="n">state</span><span class="p">,</span> <span class="n">nshown</span><span class="o">=</span><span class="n">nshown</span><span class="p">,</span> <span class="n">random</span><span class="o">=</span><span class="n">random</span><span class="p">)</span></div>



<span class="k">def</span> <span class="nf">calc_errors_from_state</span><span class="p">(</span><span class="n">problem</span><span class="p">,</span> <span class="n">state</span><span class="p">,</span> <span class="n">nshown</span><span class="o">=</span><span class="mi">50</span><span class="p">,</span> <span class="n">random</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">portion</span><span class="o">=</span><span class="mf">1.0</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Compute confidence regions for a problem from the</span>
<span class="sd">    Align the sample profiles and compute the residual difference from</span>
<span class="sd">    the measured data for a set of points returned from DREAM.</span>

<span class="sd">    *nshown* is the number of samples to include from the state.</span>

<span class="sd">    *random* is True if the samples are randomly selected, or False if</span>
<span class="sd">    the most recent samples should be used.  Use random if you have</span>
<span class="sd">    poor mixing (i.e., the parameters tend to stay fixed from generation</span>
<span class="sd">    to generation), but not random if your burn-in was too short, and</span>
<span class="sd">    you want to select from the end.</span>

<span class="sd">    Returns *errs* for :func:`show_errors`.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">points</span><span class="p">,</span> <span class="n">_logp</span> <span class="o">=</span> <span class="n">state</span><span class="o">.</span><span class="n">sample</span><span class="p">(</span><span class="n">portion</span><span class="o">=</span><span class="n">portion</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">points</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">nshown</span><span class="p">:</span>
        <span class="n">nshown</span> <span class="o">=</span> <span class="n">points</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="c1"># randomize the draw; skip the last point since state.keep_best() put</span>
    <span class="c1"># the best point at the end.</span>
    <span class="k">if</span> <span class="n">random</span><span class="p">:</span>
        <span class="n">points</span> <span class="o">=</span> <span class="n">points</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">permutation</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">points</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)]</span>
    <span class="k">return</span> <span class="n">calc_errors</span><span class="p">(</span><span class="n">problem</span><span class="p">,</span> <span class="n">points</span><span class="p">[</span><span class="o">-</span><span class="n">nshown</span><span class="p">:</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>


<span class="k">def</span> <span class="nf">calc_errors</span><span class="p">(</span><span class="n">problem</span><span class="p">,</span> <span class="n">points</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Align the sample profiles and compute the residual difference from the</span>
<span class="sd">    measured data for a set of points.</span>

<span class="sd">    The return value is arbitrary.  It is passed to the :func:`show_errors`</span>
<span class="sd">    plugin for the application.</span>
<span class="sd">    Returns *errs* for :func:`show_errors`.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">original</span> <span class="o">=</span> <span class="n">problem</span><span class="o">.</span><span class="n">getp</span><span class="p">()</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="n">ret</span> <span class="o">=</span> <span class="n">plugin</span><span class="o">.</span><span class="n">calc_errors</span><span class="p">(</span><span class="n">problem</span><span class="p">,</span> <span class="n">points</span><span class="p">)</span>
    <span class="k">except</span> <span class="ne">Exception</span><span class="p">:</span>
        <span class="n">info</span> <span class="o">=</span> <span class="p">[</span><span class="s2">&quot;error calculating distribution on model&quot;</span><span class="p">,</span>
                <span class="n">traceback</span><span class="o">.</span><span class="n">format_exc</span><span class="p">()]</span>
        <span class="n">logging</span><span class="o">.</span><span class="n">error</span><span class="p">(</span><span class="s2">&quot;</span><span class="se">\n</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">info</span><span class="p">))</span>
        <span class="n">ret</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="k">finally</span><span class="p">:</span>
        <span class="n">problem</span><span class="o">.</span><span class="n">setp</span><span class="p">(</span><span class="n">original</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">ret</span>


<span class="k">def</span> <span class="nf">show_errors</span><span class="p">(</span><span class="n">errs</span><span class="p">,</span> <span class="n">fig</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Display the confidence regions returned by :func:`calc_errors`.</span>

<span class="sd">    The content of *errs* depends on the active plugin.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">plugin</span><span class="o">.</span><span class="n">show_errors</span><span class="p">(</span><span class="n">errs</span><span class="p">,</span> <span class="n">fig</span><span class="o">=</span><span class="n">fig</span><span class="p">)</span>
</pre></div>

      </div>
      <div class="bottomnav" role="navigation" aria-label="Bottom">
      
        <p>
        <a class="uplink" href="../../index.html">Contents</a>
        </p>

      </div>

    <div class="footer" role="contentinfo">
      Created using <a href="https://www.sphinx-doc.org/">Sphinx</a> 8.1.3.
    </div>
  </body>
</html>