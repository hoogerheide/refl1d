<!DOCTYPE html>

<html lang="en" data-content_root="../../../../">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>refl1d.lib.python.rebin &#8212; Refl1D 0.7.7.post1533+gc6a0ac1 documentation</title>
    <link rel="stylesheet" type="text/css" href="../../../../_static/pygments.css?v=fa44fd50" />
    <link rel="stylesheet" type="text/css" href="../../../../_static/haiku-site.css?v=ccbba224" />
    <link rel="stylesheet" type="text/css" href="../../../../_static/plot_directive.css" />
    <script src="../../../../_static/documentation_options.js?v=132fb2fb"></script>
    <script src="../../../../_static/doctools.js?v=9bcbadda"></script>
    <script src="../../../../_static/sphinx_highlight.js?v=dc90522c"></script>
    <link rel="index" title="Index" href="../../../../genindex.html" />
    <link rel="search" title="Search" href="../../../../search.html" /> 
  </head><body>
      <div class="header" role="banner"><h1 class="heading"><a href="../../../../index.html">
          <span>Refl1D 0.7.7.post1533+gc6a0ac1 documentation</span></a></h1>
        <h2 class="heading"><span>refl1d.lib.python.rebin</span></h2>
      </div>
      <div class="topnav" role="navigation" aria-label="Top">
      
        <p>
        <a class="uplink" href="../../../../index.html">Contents</a>
        </p>

      </div>
      <div class="content" role="main">
        
        
  <h1>Source code for refl1d.lib.python.rebin</h1><div class="highlight"><pre>
<span></span><span class="kn">import</span> <span class="nn">math</span>


<div class="viewcode-block" id="BinIter">
<a class="viewcode-back" href="../../../../refl1d.lib.python.rebin.html#refl1d.lib.numba.BinIter">[docs]</a>
<span class="k">class</span> <span class="nc">BinIter</span><span class="p">:</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">n</span><span class="p">,</span> <span class="n">edges</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">n</span> <span class="o">=</span> <span class="n">n</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">edges</span> <span class="o">=</span> <span class="n">edges</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">forward</span> <span class="o">=</span> <span class="n">edges</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">edges</span><span class="p">[</span><span class="n">n</span><span class="p">]</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">forward</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">bin</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">lo</span> <span class="o">=</span> <span class="n">edges</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">hi</span> <span class="o">=</span> <span class="n">edges</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">bin</span> <span class="o">=</span> <span class="n">n</span> <span class="o">-</span> <span class="mi">1</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">lo</span> <span class="o">=</span> <span class="n">edges</span><span class="p">[</span><span class="n">n</span><span class="p">]</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">hi</span> <span class="o">=</span> <span class="n">edges</span><span class="p">[</span><span class="n">n</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">atend</span> <span class="o">=</span> <span class="n">n</span> <span class="o">&lt;</span> <span class="mi">1</span>

<div class="viewcode-block" id="BinIter.increment">
<a class="viewcode-back" href="../../../../refl1d.lib.python.rebin.html#refl1d.lib.numba.BinIter.increment">[docs]</a>
    <span class="k">def</span> <span class="nf">increment</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">atend</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">IndexError</span><span class="p">(</span><span class="s2">&quot;moving beyond final bin&quot;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">lo</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">hi</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">forward</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">bin</span> <span class="o">+=</span> <span class="mi">1</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">atend</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">bin</span> <span class="o">&gt;=</span> <span class="bp">self</span><span class="o">.</span><span class="n">n</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">atend</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">hi</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">edges</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">bin</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">atend</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">bin</span> <span class="o">==</span> <span class="mi">0</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">atend</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">bin</span> <span class="o">-=</span> <span class="mi">1</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">hi</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">edges</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">bin</span><span class="p">]</span>
        <span class="k">return</span> <span class="bp">self</span></div>
</div>



<div class="viewcode-block" id="rebin_counts_portion">
<a class="viewcode-back" href="../../../../refl1d.lib.python.rebin.html#refl1d.lib.numba.rebin_counts_portion">[docs]</a>
<span class="k">def</span> <span class="nf">rebin_counts_portion</span><span class="p">(</span><span class="n">Nold</span><span class="p">,</span> <span class="n">vold</span><span class="p">,</span> <span class="n">Iold</span><span class="p">,</span> <span class="n">Nnew</span><span class="p">,</span> <span class="n">vnew</span><span class="p">,</span> <span class="n">Inew</span><span class="p">,</span> <span class="n">ND_portion</span><span class="p">):</span>
    <span class="c1"># Note: inspired by rebin from OpenGenie, but using counts per bin</span>
    <span class="c1"># rather than rates.</span>

    <span class="c1"># Does not work in place</span>
    <span class="k">if</span> <span class="n">Iold</span> <span class="ow">is</span> <span class="n">Inew</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;does not work in place&quot;</span><span class="p">)</span>

    <span class="c1"># Traverse both sets of bin edges; if there is an overlap, add the portion</span>
    <span class="c1"># of the overlapping old bin to the new bin.</span>
    <span class="n">_from</span> <span class="o">=</span> <span class="n">BinIter</span><span class="p">(</span><span class="n">Nold</span><span class="p">,</span> <span class="n">vold</span><span class="p">)</span>
    <span class="n">_to</span> <span class="o">=</span> <span class="n">BinIter</span><span class="p">(</span><span class="n">Nnew</span><span class="p">,</span> <span class="n">vnew</span><span class="p">)</span>
    <span class="k">while</span> <span class="ow">not</span> <span class="n">_from</span><span class="o">.</span><span class="n">atend</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">_to</span><span class="o">.</span><span class="n">atend</span><span class="p">:</span>
        <span class="c1"># std::cout &lt;&lt; &quot;from &quot; &lt;&lt; from.bin &lt;&lt; &quot;: [&quot; &lt;&lt; from.lo &lt;&lt; &quot;, &quot; &lt;&lt; from.hi &lt;&lt; &quot;]\n&quot;;</span>
        <span class="c1"># std::cout &lt;&lt; &quot;to &quot; &lt;&lt; to.bin &lt;&lt; &quot;: [&quot; &lt;&lt; to.lo &lt;&lt; &quot;, &quot; &lt;&lt; to.hi &lt;&lt; &quot;]\n&quot;;</span>
        <span class="k">if</span> <span class="n">_to</span><span class="o">.</span><span class="n">hi</span> <span class="o">&lt;=</span> <span class="n">_from</span><span class="o">.</span><span class="n">lo</span><span class="p">:</span>
            <span class="n">_to</span><span class="o">.</span><span class="n">increment</span><span class="p">()</span>  <span class="c1"># new must catch up to old</span>
        <span class="k">elif</span> <span class="n">_from</span><span class="o">.</span><span class="n">hi</span> <span class="o">&lt;=</span> <span class="n">_to</span><span class="o">.</span><span class="n">lo</span><span class="p">:</span>
            <span class="n">_from</span><span class="o">.</span><span class="n">increment</span><span class="p">()</span>  <span class="c1"># old must catch up to new</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">overlap</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="n">_from</span><span class="o">.</span><span class="n">hi</span><span class="p">,</span> <span class="n">_to</span><span class="o">.</span><span class="n">hi</span><span class="p">)</span> <span class="o">-</span> <span class="nb">max</span><span class="p">(</span><span class="n">_from</span><span class="o">.</span><span class="n">lo</span><span class="p">,</span> <span class="n">_to</span><span class="o">.</span><span class="n">lo</span><span class="p">)</span>
            <span class="n">portion</span> <span class="o">=</span> <span class="n">overlap</span> <span class="o">/</span> <span class="p">(</span><span class="n">_from</span><span class="o">.</span><span class="n">hi</span> <span class="o">-</span> <span class="n">_from</span><span class="o">.</span><span class="n">lo</span><span class="p">)</span>
            <span class="n">Inew</span><span class="p">[</span><span class="n">_to</span><span class="o">.</span><span class="n">bin</span><span class="p">]</span> <span class="o">+=</span> <span class="n">Iold</span><span class="p">[</span><span class="n">_from</span><span class="o">.</span><span class="n">bin</span><span class="p">]</span> <span class="o">*</span> <span class="n">portion</span> <span class="o">*</span> <span class="n">ND_portion</span>
            <span class="k">if</span> <span class="n">_to</span><span class="o">.</span><span class="n">hi</span> <span class="o">&gt;</span> <span class="n">_from</span><span class="o">.</span><span class="n">hi</span><span class="p">:</span>
                <span class="n">_from</span><span class="o">.</span><span class="n">increment</span><span class="p">()</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">_to</span><span class="o">.</span><span class="n">increment</span><span class="p">()</span></div>



<div class="viewcode-block" id="rebin_counts_old">
<a class="viewcode-back" href="../../../../refl1d.lib.python.rebin.html#refl1d.lib.numba.rebin_counts_old">[docs]</a>
<span class="k">def</span> <span class="nf">rebin_counts_old</span><span class="p">(</span><span class="n">Nold</span><span class="p">,</span> <span class="n">xold</span><span class="p">,</span> <span class="n">Iold</span><span class="p">,</span> <span class="n">Nnew</span><span class="p">,</span> <span class="n">xnew</span><span class="p">,</span> <span class="n">Inew</span><span class="p">):</span>
    <span class="c1"># Note: inspired by rebin from OpenGenie, but using counts per bin</span>
    <span class="c1"># rather than rates.</span>

    <span class="c1"># Clear the new bins</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">Nnew</span><span class="p">):</span>
        <span class="n">Inew</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>

    <span class="n">rebin_counts_portion</span><span class="p">(</span><span class="n">Nold</span><span class="p">,</span> <span class="n">xold</span><span class="p">,</span> <span class="n">Iold</span><span class="p">,</span> <span class="n">Nnew</span><span class="p">,</span> <span class="n">xnew</span><span class="p">,</span> <span class="n">Inew</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">)</span></div>



<div class="viewcode-block" id="rebin_counts">
<a class="viewcode-back" href="../../../../refl1d.lib.python.rebin.html#refl1d.lib.numba.rebin_counts">[docs]</a>
<span class="k">def</span> <span class="nf">rebin_counts</span><span class="p">(</span><span class="n">xold</span><span class="p">,</span> <span class="n">Iold</span><span class="p">,</span> <span class="n">xnew</span><span class="p">,</span> <span class="n">Inew</span><span class="p">):</span>
    <span class="c1"># Note: inspired by rebin from OpenGenie, but using counts per bin</span>
    <span class="c1"># rather than rates.</span>
    <span class="n">Nold</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">Iold</span><span class="p">)</span>
    <span class="n">Nnew</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">Inew</span><span class="p">)</span>
    <span class="c1"># Clear the new bins</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">Nnew</span><span class="p">):</span>
        <span class="n">Inew</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>

    <span class="n">rebin_counts_portion</span><span class="p">(</span><span class="n">Nold</span><span class="p">,</span> <span class="n">xold</span><span class="p">,</span> <span class="n">Iold</span><span class="p">,</span> <span class="n">Nnew</span><span class="p">,</span> <span class="n">xnew</span><span class="p">,</span> <span class="n">Inew</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">)</span></div>



<div class="viewcode-block" id="rebin_intensity">
<a class="viewcode-back" href="../../../../refl1d.lib.python.rebin.html#refl1d.lib.numba.rebin_intensity">[docs]</a>
<span class="k">def</span> <span class="nf">rebin_intensity</span><span class="p">(</span><span class="n">Nold</span><span class="p">,</span> <span class="n">xold</span><span class="p">,</span> <span class="n">Iold</span><span class="p">,</span> <span class="n">dIold</span><span class="p">,</span> <span class="n">Nnew</span><span class="p">,</span> <span class="n">xnew</span><span class="p">,</span> <span class="n">Inew</span><span class="p">,</span> <span class="n">dInew</span><span class="p">):</span>
    <span class="c1"># Note: inspired by rebin from OpenGenie, but using counts per bin rather than rates.</span>

    <span class="c1"># Clear the new bins</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">Nnew</span><span class="p">):</span>
        <span class="n">dInew</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">Inew</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>

    <span class="c1"># Traverse both sets of bin edges; if there is an overlap, add the portion</span>
    <span class="c1"># of the overlapping old bin to the new bin.</span>
    <span class="n">_from</span> <span class="o">=</span> <span class="n">BinIter</span><span class="p">(</span><span class="n">Nold</span><span class="p">,</span> <span class="n">xold</span><span class="p">)</span>
    <span class="n">_to</span> <span class="o">=</span> <span class="n">BinIter</span><span class="p">(</span><span class="n">Nnew</span><span class="p">,</span> <span class="n">xnew</span><span class="p">)</span>
    <span class="k">while</span> <span class="ow">not</span> <span class="n">_from</span><span class="o">.</span><span class="n">atend</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">_to</span><span class="o">.</span><span class="n">atend</span><span class="p">:</span>
        <span class="c1"># std::cout &lt;&lt; &quot;from &quot; &lt;&lt; from.bin &lt;&lt; &quot;: [&quot; &lt;&lt; from.lo &lt;&lt; &quot;, &quot; &lt;&lt; from.hi &lt;&lt; &quot;]\n&quot;;</span>
        <span class="c1"># std::cout &lt;&lt; &quot;to &quot; &lt;&lt; to.bin &lt;&lt; &quot;: [&quot; &lt;&lt; to.lo &lt;&lt; &quot;, &quot; &lt;&lt; to.hi &lt;&lt; &quot;]\n&quot;;</span>
        <span class="k">if</span> <span class="n">_to</span><span class="o">.</span><span class="n">hi</span> <span class="o">&lt;=</span> <span class="n">_from</span><span class="o">.</span><span class="n">lo</span><span class="p">:</span>
            <span class="n">_to</span><span class="o">.</span><span class="n">increment</span><span class="p">()</span>  <span class="c1"># new must catch up to old</span>
        <span class="k">elif</span> <span class="n">_from</span><span class="o">.</span><span class="n">hi</span> <span class="o">&lt;=</span> <span class="n">_to</span><span class="o">.</span><span class="n">lo</span><span class="p">:</span>
            <span class="n">_from</span><span class="o">.</span><span class="n">increment</span><span class="p">()</span>  <span class="c1"># old must catch up to new</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">overlap</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="n">_from</span><span class="o">.</span><span class="n">hi</span><span class="p">,</span> <span class="n">_to</span><span class="o">.</span><span class="n">hi</span><span class="p">)</span> <span class="o">-</span> <span class="nb">max</span><span class="p">(</span><span class="n">_from</span><span class="o">.</span><span class="n">lo</span><span class="p">,</span> <span class="n">_to</span><span class="o">.</span><span class="n">lo</span><span class="p">)</span>
            <span class="n">portion</span> <span class="o">=</span> <span class="n">overlap</span> <span class="o">/</span> <span class="p">(</span><span class="n">_from</span><span class="o">.</span><span class="n">hi</span> <span class="o">-</span> <span class="n">_from</span><span class="o">.</span><span class="n">lo</span><span class="p">)</span>

            <span class="n">Inew</span><span class="p">[</span><span class="n">_to</span><span class="o">.</span><span class="n">bin</span><span class="p">]</span> <span class="o">+=</span> <span class="p">(</span><span class="n">Iold</span><span class="p">[</span><span class="n">_from</span><span class="o">.</span><span class="n">bin</span><span class="p">])</span> <span class="o">*</span> <span class="n">portion</span>
            <span class="c1"># add in quadrature</span>
            <span class="n">dInew</span><span class="p">[</span><span class="n">_to</span><span class="o">.</span><span class="n">bin</span><span class="p">]</span> <span class="o">+=</span> <span class="p">(</span><span class="n">dIold</span><span class="p">[</span><span class="n">_from</span><span class="o">.</span><span class="n">bin</span><span class="p">]</span> <span class="o">*</span> <span class="n">portion</span><span class="p">)</span> <span class="o">**</span> <span class="mi">2</span>
            <span class="k">if</span> <span class="n">_to</span><span class="o">.</span><span class="n">hi</span> <span class="o">&gt;</span> <span class="n">_from</span><span class="o">.</span><span class="n">hi</span><span class="p">:</span>
                <span class="n">_from</span><span class="o">.</span><span class="n">increment</span><span class="p">()</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">_to</span><span class="o">.</span><span class="n">increment</span><span class="p">()</span>

    <span class="c1"># Convert variance to standard deviation.</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">Nnew</span><span class="p">):</span>
        <span class="n">dInew</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">math</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">dInew</span><span class="p">[</span><span class="n">i</span><span class="p">])</span></div>



<div class="viewcode-block" id="rebin_counts_2D">
<a class="viewcode-back" href="../../../../refl1d.lib.python.rebin.html#refl1d.lib.numba.rebin_counts_2D">[docs]</a>
<span class="k">def</span> <span class="nf">rebin_counts_2D</span><span class="p">(</span><span class="n">xold</span><span class="p">,</span> <span class="n">yold</span><span class="p">,</span> <span class="n">Iold</span><span class="p">,</span> <span class="n">xnew</span><span class="p">,</span> <span class="n">ynew</span><span class="p">,</span> <span class="n">Inew</span><span class="p">):</span>
    <span class="n">Nxold</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">xold</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span>
    <span class="n">Nyold</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">yold</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span>
    <span class="n">Nxnew</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">xnew</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span>
    <span class="n">Nynew</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">ynew</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span>

    <span class="c1"># Clear the new bins</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">Nxnew</span><span class="p">):</span>
        <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">Nynew</span><span class="p">):</span>
            <span class="n">Inew</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>

    <span class="c1"># Traverse both sets of bin edges; if there is an overlap, add the portion</span>
    <span class="c1"># of the overlapping old bin to the new bin.  Scale this by the portion</span>
    <span class="c1"># of the overlap in y.</span>
    <span class="n">_from</span> <span class="o">=</span> <span class="n">BinIter</span><span class="p">(</span><span class="n">Nxold</span><span class="p">,</span> <span class="n">xold</span><span class="p">)</span>
    <span class="n">_to</span> <span class="o">=</span> <span class="n">BinIter</span><span class="p">(</span><span class="n">Nxnew</span><span class="p">,</span> <span class="n">xnew</span><span class="p">)</span>

    <span class="k">while</span> <span class="ow">not</span> <span class="n">_from</span><span class="o">.</span><span class="n">atend</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">_to</span><span class="o">.</span><span class="n">atend</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">_to</span><span class="o">.</span><span class="n">hi</span> <span class="o">&lt;=</span> <span class="n">_from</span><span class="o">.</span><span class="n">lo</span><span class="p">:</span>
            <span class="n">_to</span><span class="o">.</span><span class="n">increment</span><span class="p">()</span>  <span class="c1"># new must catch up to old</span>
        <span class="k">elif</span> <span class="n">_from</span><span class="o">.</span><span class="n">hi</span> <span class="o">&lt;=</span> <span class="n">_to</span><span class="o">.</span><span class="n">lo</span><span class="p">:</span>
            <span class="n">_from</span><span class="o">.</span><span class="n">increment</span><span class="p">()</span>  <span class="c1"># old must catch up to new</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">overlap</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="n">_from</span><span class="o">.</span><span class="n">hi</span><span class="p">,</span> <span class="n">_to</span><span class="o">.</span><span class="n">hi</span><span class="p">)</span> <span class="o">-</span> <span class="nb">max</span><span class="p">(</span><span class="n">_from</span><span class="o">.</span><span class="n">lo</span><span class="p">,</span> <span class="n">_to</span><span class="o">.</span><span class="n">lo</span><span class="p">)</span>
            <span class="n">portion</span> <span class="o">=</span> <span class="n">overlap</span> <span class="o">/</span> <span class="p">(</span><span class="n">_from</span><span class="o">.</span><span class="n">hi</span> <span class="o">-</span> <span class="n">_from</span><span class="o">.</span><span class="n">lo</span><span class="p">)</span>
            <span class="n">rebin_counts_portion</span><span class="p">(</span><span class="n">Nyold</span><span class="p">,</span> <span class="n">yold</span><span class="p">,</span> <span class="n">Iold</span><span class="p">[</span><span class="n">_from</span><span class="o">.</span><span class="n">bin</span><span class="p">],</span> <span class="n">Nynew</span><span class="p">,</span> <span class="n">ynew</span><span class="p">,</span> <span class="n">Inew</span><span class="p">[</span><span class="n">_to</span><span class="o">.</span><span class="n">bin</span><span class="p">],</span> <span class="n">portion</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">_to</span><span class="o">.</span><span class="n">hi</span> <span class="o">&gt;</span> <span class="n">_from</span><span class="o">.</span><span class="n">hi</span><span class="p">:</span>
                <span class="n">_from</span><span class="o">.</span><span class="n">increment</span><span class="p">()</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">_to</span><span class="o">.</span><span class="n">increment</span><span class="p">()</span></div>

</pre></div>

      </div>
      <div class="bottomnav" role="navigation" aria-label="Bottom">
      
        <p>
        <a class="uplink" href="../../../../index.html">Contents</a>
        </p>

      </div>

    <div class="footer" role="contentinfo">
      Created using <a href="https://www.sphinx-doc.org/">Sphinx</a> 8.1.3.
    </div>
  </body>
</html>