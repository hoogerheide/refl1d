<!DOCTYPE html>

<html lang="en" data-content_root="../../../../">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>refl1d.lib.python.contract_profile &#8212; Refl1D 0.7.7.post1533+gc6a0ac1 documentation</title>
    <link rel="stylesheet" type="text/css" href="../../../../_static/pygments.css?v=fa44fd50" />
    <link rel="stylesheet" type="text/css" href="../../../../_static/haiku-site.css?v=ccbba224" />
    <link rel="stylesheet" type="text/css" href="../../../../_static/plot_directive.css" />
    <script src="../../../../_static/documentation_options.js?v=132fb2fb"></script>
    <script src="../../../../_static/doctools.js?v=9bcbadda"></script>
    <script src="../../../../_static/sphinx_highlight.js?v=dc90522c"></script>
    <link rel="index" title="Index" href="../../../../genindex.html" />
    <link rel="search" title="Search" href="../../../../search.html" /> 
  </head><body>
      <div class="header" role="banner"><h1 class="heading"><a href="../../../../index.html">
          <span>Refl1D 0.7.7.post1533+gc6a0ac1 documentation</span></a></h1>
        <h2 class="heading"><span>refl1d.lib.python.contract_profile</span></h2>
      </div>
      <div class="topnav" role="navigation" aria-label="Top">
      
        <p>
        <a class="uplink" href="../../../../index.html">Contents</a>
        </p>

      </div>
      <div class="content" role="main">
        
        
  <h1>Source code for refl1d.lib.python.contract_profile</h1><div class="highlight"><pre>
<span></span><span class="kn">import</span> <span class="nn">math</span>

<span class="n">Z_EPS</span> <span class="o">=</span> <span class="mf">1e-6</span>


<div class="viewcode-block" id="align_magnetic">
<a class="viewcode-back" href="../../../../refl1d.lib.python.contract_profile.html#refl1d.lib.numba.align_magnetic">[docs]</a>
<span class="k">def</span> <span class="nf">align_magnetic</span><span class="p">(</span><span class="n">d</span><span class="p">,</span> <span class="n">sigma</span><span class="p">,</span> <span class="n">rho</span><span class="p">,</span> <span class="n">irho</span><span class="p">,</span> <span class="n">dM</span><span class="p">,</span> <span class="n">sigmaM</span><span class="p">,</span> <span class="n">rhoM</span><span class="p">,</span> <span class="n">thetaM</span><span class="p">,</span> <span class="n">output_flat</span><span class="p">):</span>
    <span class="c1"># ignoring thickness d on the first and last layers</span>
    <span class="c1"># ignoring interface width sigma on the last layer</span>
    <span class="n">nlayers</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">d</span><span class="p">)</span>
    <span class="n">nlayersM</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">dM</span><span class="p">)</span>
    <span class="n">noutput</span> <span class="o">=</span> <span class="n">nlayers</span> <span class="o">+</span> <span class="n">nlayersM</span>

    <span class="c1"># making sure there are at least two layers</span>
    <span class="k">if</span> <span class="n">nlayers</span> <span class="o">&lt;</span> <span class="mi">2</span> <span class="ow">or</span> <span class="n">nlayersM</span> <span class="o">&lt;</span> <span class="mi">2</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;only works with more than one layer&quot;</span><span class="p">)</span>

    <span class="n">output</span> <span class="o">=</span> <span class="n">output_flat</span>
    <span class="n">magnetic</span> <span class="o">=</span> <span class="mi">0</span>  <span class="c1"># current magnetic layer index</span>
    <span class="n">nuclear</span> <span class="o">=</span> <span class="mi">0</span>  <span class="c1"># current nuclear layer index</span>
    <span class="n">z</span> <span class="o">=</span> <span class="mf">0.0</span>  <span class="c1"># current interface depth</span>
    <span class="n">next_z</span> <span class="o">=</span> <span class="mf">0.0</span>  <span class="c1"># next nuclear interface</span>
    <span class="n">next_zM</span> <span class="o">=</span> <span class="mf">0.0</span>  <span class="c1"># next magnetic interface</span>
    <span class="c1"># int active = 3# active interfaces, active&amp;0x1 for nuclear, active&amp;0x2 for magnetic</span>

    <span class="n">k</span> <span class="o">=</span> <span class="mi">0</span>  <span class="c1"># current output layer index</span>
    <span class="k">while</span> <span class="kc">True</span><span class="p">:</span>
        <span class="c1"># repeat over all nuclear/magnetic layers</span>
        <span class="k">if</span> <span class="n">k</span> <span class="o">==</span> <span class="n">noutput</span><span class="p">:</span>
            <span class="k">return</span> <span class="o">-</span><span class="mi">1</span>  <span class="c1"># exceeds capacity of output</span>

        <span class="c1"># printf(&quot;%d: %d %d %g %g %g\n&quot;, k, nuclear, magnetic, z, next_z, next_zM)</span>
        <span class="c1"># printf(&quot;%g %g %g %g\n&quot;, rho[nuclear], irho[nuclear], rhoM[magnetic], thetaM[magnetic])</span>
        <span class="c1"># printf(&quot;%g %g %g %g\n&quot;, d[nuclear], sigma[nuclear], dM[magnetic], sigmaM[magnetic])</span>

        <span class="c1"># Set the scattering strength using the current parameters</span>
        <span class="n">output</span><span class="p">[</span><span class="n">k</span><span class="p">][</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="n">rho</span><span class="p">[</span><span class="n">nuclear</span><span class="p">]</span>
        <span class="n">output</span><span class="p">[</span><span class="n">k</span><span class="p">][</span><span class="mi">3</span><span class="p">]</span> <span class="o">=</span> <span class="n">irho</span><span class="p">[</span><span class="n">nuclear</span><span class="p">]</span>
        <span class="n">output</span><span class="p">[</span><span class="n">k</span><span class="p">][</span><span class="mi">4</span><span class="p">]</span> <span class="o">=</span> <span class="n">rhoM</span><span class="p">[</span><span class="n">magnetic</span><span class="p">]</span>
        <span class="n">output</span><span class="p">[</span><span class="n">k</span><span class="p">][</span><span class="mi">5</span><span class="p">]</span> <span class="o">=</span> <span class="n">thetaM</span><span class="p">[</span><span class="n">magnetic</span><span class="p">]</span>

        <span class="c1"># Check if we are at the last layer for both nuclear and magnetic</span>
        <span class="c1"># If so set thickness and interface width to zero.  We are doing a</span>
        <span class="c1"># center of the loop exit in order to make sure that the final layer</span>
        <span class="c1"># is added.</span>

        <span class="k">if</span> <span class="n">magnetic</span> <span class="o">==</span> <span class="n">nlayersM</span> <span class="o">-</span> <span class="mi">1</span> <span class="ow">and</span> <span class="n">nuclear</span> <span class="o">==</span> <span class="n">nlayers</span> <span class="o">-</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">output</span><span class="p">[</span><span class="n">k</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mf">0.0</span>
            <span class="n">output</span><span class="p">[</span><span class="n">k</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="mf">0.0</span>
            <span class="n">k</span> <span class="o">+=</span> <span class="mi">1</span>
            <span class="k">break</span>

        <span class="c1"># Determine if we are adding the nuclear or the magnetic interface next,</span>
        <span class="c1"># or possibly both.  The order of the conditions is important.</span>
        <span class="c1">#</span>
        <span class="c1"># Note: the final value for next_z/next_zM is not defined.  Rather than</span>
        <span class="c1"># checking if we are on the last layer we simply add the value of the</span>
        <span class="c1"># last thickness to z, which may be 0, nan, inf, or anything else.  This</span>
        <span class="c1"># doesn&#39;t affect the algorithm since we don&#39;t look at next_z when we are</span>
        <span class="c1"># on the final nuclear layer or next_zM when we are on the final magnetic</span>
        <span class="c1"># layer.</span>
        <span class="c1">#</span>
        <span class="c1"># Note: averaging nearly aligned interfaces can lead to negative thickness</span>
        <span class="c1"># Consider nuc = [1-a, 0, 1] and mag = [1+a, 1, 1] for 2a &lt; Z_EPS.</span>
        <span class="c1"># On the first step we set next_z to 1-a, next_zM to 1+a and z to the</span>
        <span class="c1"># average of 1-a and 1+a, which is 1.  On the second step next_z is</span>
        <span class="c1"># still 1-a, so the thickness next_z - z = -a. Since a is tiny we can just</span>
        <span class="c1"># pretend that -a == zero by setting thickness to fmax(next_z - z, 0.0).</span>

        <span class="k">if</span> <span class="n">nuclear</span> <span class="o">==</span> <span class="n">nlayers</span> <span class="o">-</span> <span class="mi">1</span><span class="p">:</span>
            <span class="c1"># No more nuclear layers... play out the remaining magnetic layers.</span>
            <span class="n">output</span><span class="p">[</span><span class="n">k</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">next_zM</span> <span class="o">-</span> <span class="n">z</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">)</span>
            <span class="n">output</span><span class="p">[</span><span class="n">k</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">sigmaM</span><span class="p">[</span><span class="n">magnetic</span><span class="p">]</span>
            <span class="n">magnetic</span> <span class="o">+=</span> <span class="mi">1</span>
            <span class="n">next_zM</span> <span class="o">+=</span> <span class="n">dM</span><span class="p">[</span><span class="n">magnetic</span><span class="p">]</span>
        <span class="k">elif</span> <span class="n">magnetic</span> <span class="o">==</span> <span class="n">nlayersM</span> <span class="o">-</span> <span class="mi">1</span><span class="p">:</span>
            <span class="c1"># No more magnetic layers... play out the remaining nuclear layers.</span>
            <span class="n">output</span><span class="p">[</span><span class="n">k</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">next_z</span> <span class="o">-</span> <span class="n">z</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">)</span>
            <span class="n">output</span><span class="p">[</span><span class="n">k</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">sigma</span><span class="p">[</span><span class="n">nuclear</span><span class="p">]</span>
            <span class="n">nuclear</span> <span class="o">+=</span> <span class="mi">1</span>
            <span class="n">next_z</span> <span class="o">+=</span> <span class="n">d</span><span class="p">[</span><span class="n">nuclear</span><span class="p">]</span>
        <span class="k">elif</span> <span class="n">math</span><span class="o">.</span><span class="n">fabs</span><span class="p">(</span><span class="n">next_z</span> <span class="o">-</span> <span class="n">next_zM</span><span class="p">)</span> <span class="o">&lt;</span> <span class="n">Z_EPS</span> <span class="ow">and</span> <span class="n">math</span><span class="o">.</span><span class="n">fabs</span><span class="p">(</span><span class="n">sigma</span><span class="p">[</span><span class="n">nuclear</span><span class="p">]</span> <span class="o">-</span> <span class="n">sigmaM</span><span class="p">[</span><span class="n">magnetic</span><span class="p">])</span> <span class="o">&lt;</span> <span class="n">Z_EPS</span><span class="p">:</span>
            <span class="c1"># Matching nuclear/magnetic boundary, with almost identical interfaces.</span>
            <span class="c1"># Increment both nuclear and magnetic layers.</span>
            <span class="n">output</span><span class="p">[</span><span class="n">k</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="mf">0.5</span> <span class="o">*</span> <span class="p">(</span><span class="n">next_z</span> <span class="o">+</span> <span class="n">next_zM</span><span class="p">)</span> <span class="o">-</span> <span class="n">z</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">)</span>
            <span class="n">output</span><span class="p">[</span><span class="n">k</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="mf">0.5</span> <span class="o">*</span> <span class="p">(</span><span class="n">sigma</span><span class="p">[</span><span class="n">nuclear</span><span class="p">]</span> <span class="o">+</span> <span class="n">sigmaM</span><span class="p">[</span><span class="n">magnetic</span><span class="p">])</span>
            <span class="n">nuclear</span> <span class="o">+=</span> <span class="mi">1</span>
            <span class="n">next_z</span> <span class="o">+=</span> <span class="n">d</span><span class="p">[</span><span class="n">nuclear</span><span class="p">]</span>
            <span class="n">magnetic</span> <span class="o">+=</span> <span class="mi">1</span>
            <span class="n">next_zM</span> <span class="o">+=</span> <span class="n">dM</span><span class="p">[</span><span class="n">magnetic</span><span class="p">]</span>
        <span class="k">elif</span> <span class="n">next_zM</span> <span class="o">&lt;</span> <span class="n">next_z</span><span class="p">:</span>
            <span class="c1"># Magnetic boundary comes before nuclear boundary, so increment magnetic.</span>
            <span class="n">output</span><span class="p">[</span><span class="n">k</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">next_zM</span> <span class="o">-</span> <span class="n">z</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">)</span>
            <span class="n">output</span><span class="p">[</span><span class="n">k</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">sigmaM</span><span class="p">[</span><span class="n">magnetic</span><span class="p">]</span>
            <span class="n">magnetic</span> <span class="o">+=</span> <span class="mi">1</span>
            <span class="n">next_zM</span> <span class="o">+=</span> <span class="n">dM</span><span class="p">[</span><span class="n">magnetic</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># Nuclear boundary comes before magnetic boundary</span>
            <span class="c1"># OR nuclear and magnetic boundaries match but interfaces are different.</span>
            <span class="c1"># so increment nuclear.</span>
            <span class="n">output</span><span class="p">[</span><span class="n">k</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">next_z</span> <span class="o">-</span> <span class="n">z</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">)</span>
            <span class="n">output</span><span class="p">[</span><span class="n">k</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">sigma</span><span class="p">[</span><span class="n">nuclear</span><span class="p">]</span>
            <span class="n">nuclear</span> <span class="o">+=</span> <span class="mi">1</span>
            <span class="n">next_z</span> <span class="o">+=</span> <span class="n">d</span><span class="p">[</span><span class="n">nuclear</span><span class="p">]</span>

        <span class="n">z</span> <span class="o">+=</span> <span class="n">output</span><span class="p">[</span><span class="n">k</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">k</span> <span class="o">+=</span> <span class="mi">1</span>

    <span class="k">return</span> <span class="n">k</span></div>



<div class="viewcode-block" id="contract_mag">
<a class="viewcode-back" href="../../../../refl1d.lib.python.contract_profile.html#refl1d.lib.numba.contract_mag">[docs]</a>
<span class="k">def</span> <span class="nf">contract_mag</span><span class="p">(</span><span class="n">d</span><span class="p">,</span> <span class="n">sigma</span><span class="p">,</span> <span class="n">rho</span><span class="p">,</span> <span class="n">irho</span><span class="p">,</span> <span class="n">rhoM</span><span class="p">,</span> <span class="n">thetaM</span><span class="p">,</span> <span class="n">dA</span><span class="p">):</span>
    <span class="n">n</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">d</span><span class="p">)</span>
    <span class="n">m</span> <span class="o">=</span> <span class="n">n</span> <span class="o">-</span> <span class="mi">1</span>  <span class="c1"># /* last middle layer */</span>
    <span class="n">i</span> <span class="o">=</span> <span class="n">newi</span> <span class="o">=</span> <span class="mi">1</span>  <span class="c1"># /* Skip the substrate */</span>
    <span class="k">while</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">m</span><span class="p">:</span>
        <span class="c1"># /* Get ready for the next layer */</span>
        <span class="c1"># /* Accumulation of the first row happens in the inner loop */</span>
        <span class="n">dz</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">rhoarea</span> <span class="o">=</span> <span class="n">irhoarea</span> <span class="o">=</span> <span class="n">rhoMpara_area</span> <span class="o">=</span> <span class="n">rhoMperp_area</span> <span class="o">=</span> <span class="n">thetaM_area</span> <span class="o">=</span> <span class="mf">0.0</span>
        <span class="n">rholo</span> <span class="o">=</span> <span class="n">rhohi</span> <span class="o">=</span> <span class="n">rho</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
        <span class="n">irholo</span> <span class="o">=</span> <span class="n">irhohi</span> <span class="o">=</span> <span class="n">irho</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>

        <span class="c1"># /*</span>
        <span class="c1">#  * averaged thetaM is from atan2 (when rhoM is nonzero)</span>
        <span class="c1">#  * which returns values in the range -180 to 180,</span>
        <span class="c1">#  * so we keep track of the phase offset of the input</span>
        <span class="c1">#  * to match it afterward</span>
        <span class="c1">#  */</span>
        <span class="n">thetaM_phase_offset</span> <span class="o">=</span> <span class="p">(</span><span class="n">thetaM</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">+</span> <span class="mf">180.0</span><span class="p">)</span> <span class="o">//</span> <span class="mf">360.0</span>

        <span class="c1"># /* Pre-calculate projections */</span>
        <span class="n">rhoM_sign</span> <span class="o">=</span> <span class="n">math</span><span class="o">.</span><span class="n">copysign</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">rhoM</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
        <span class="n">thetaM_radians</span> <span class="o">=</span> <span class="n">thetaM</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">*</span> <span class="n">math</span><span class="o">.</span><span class="n">pi</span> <span class="o">/</span> <span class="mf">180.0</span>
        <span class="n">rhoMpara</span> <span class="o">=</span> <span class="n">rhoM</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">*</span> <span class="n">math</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">thetaM_radians</span><span class="p">)</span>
        <span class="n">rhoMperp</span> <span class="o">=</span> <span class="n">rhoM</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">*</span> <span class="n">math</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">thetaM_radians</span><span class="p">)</span>
        <span class="c1"># /*</span>
        <span class="c1">#  * Note that mpara indicates M when theta_M = 0,</span>
        <span class="c1">#  * and mperp indicates M when theta_M = 90,</span>
        <span class="c1">#  * but in most cases M is parallel to H when theta_M = 270</span>
        <span class="c1">#  * and Aguide = 270</span>
        <span class="c1">#  */</span>
        <span class="n">mparalo</span> <span class="o">=</span> <span class="n">mparahi</span> <span class="o">=</span> <span class="n">rhoMpara</span>
        <span class="n">mperplo</span> <span class="o">=</span> <span class="n">mperphi</span> <span class="o">=</span> <span class="n">rhoMperp</span>

        <span class="c1"># /* Accumulate slices into layer */</span>
        <span class="k">while</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">m</span><span class="p">:</span>
            <span class="c1"># /* Accumulate next slice */</span>
            <span class="n">dz</span> <span class="o">+=</span> <span class="n">d</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
            <span class="n">rhoarea</span> <span class="o">+=</span> <span class="n">d</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">*</span> <span class="n">rho</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
            <span class="n">irhoarea</span> <span class="o">+=</span> <span class="n">d</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">*</span> <span class="n">irho</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
            <span class="c1"># /* thetaM_area is only used if rhoM is zero */</span>
            <span class="n">thetaM_area</span> <span class="o">+=</span> <span class="n">d</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">*</span> <span class="n">thetaM</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
            <span class="c1"># /* Use pre-calculated next values */</span>
            <span class="n">rhoMpara_area</span> <span class="o">+=</span> <span class="n">rhoMpara</span> <span class="o">*</span> <span class="n">d</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
            <span class="n">rhoMperp_area</span> <span class="o">+=</span> <span class="n">rhoMperp</span> <span class="o">*</span> <span class="n">d</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>

            <span class="c1"># /* If no more slices or sigma != 0, break immediately */</span>
            <span class="n">i</span> <span class="o">+=</span> <span class="mi">1</span>
            <span class="k">if</span> <span class="n">i</span> <span class="o">==</span> <span class="n">n</span> <span class="ow">or</span> <span class="n">sigma</span><span class="p">[</span><span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span> <span class="o">!=</span> <span class="mf">0.0</span><span class="p">:</span>
                <span class="k">break</span>

            <span class="c1"># /* If next slice exceeds limit then break */</span>
            <span class="k">if</span> <span class="n">rho</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">rholo</span><span class="p">:</span>
                <span class="n">rholo</span> <span class="o">=</span> <span class="n">rho</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
            <span class="k">if</span> <span class="n">rho</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">rhohi</span><span class="p">:</span>
                <span class="n">rhohi</span> <span class="o">=</span> <span class="n">rho</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">rhohi</span> <span class="o">-</span> <span class="n">rholo</span><span class="p">)</span> <span class="o">*</span> <span class="p">(</span><span class="n">dz</span> <span class="o">+</span> <span class="n">d</span><span class="p">[</span><span class="n">i</span><span class="p">])</span> <span class="o">&gt;</span> <span class="n">dA</span><span class="p">:</span>
                <span class="k">break</span>

            <span class="k">if</span> <span class="n">irho</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">irholo</span><span class="p">:</span>
                <span class="n">irholo</span> <span class="o">=</span> <span class="n">irho</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
            <span class="k">if</span> <span class="n">irho</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">irhohi</span><span class="p">:</span>
                <span class="n">irhohi</span> <span class="o">=</span> <span class="n">irho</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">irhohi</span> <span class="o">-</span> <span class="n">irholo</span><span class="p">)</span> <span class="o">*</span> <span class="p">(</span><span class="n">dz</span> <span class="o">+</span> <span class="n">d</span><span class="p">[</span><span class="n">i</span><span class="p">])</span> <span class="o">&gt;</span> <span class="n">dA</span><span class="p">:</span>
                <span class="k">break</span>

            <span class="c1"># /* Pre-calculate projections of next layer */</span>
            <span class="n">thetaM_radians</span> <span class="o">=</span> <span class="n">thetaM</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">*</span> <span class="n">math</span><span class="o">.</span><span class="n">pi</span> <span class="o">/</span> <span class="mf">180.0</span>
            <span class="n">rhoMpara</span> <span class="o">=</span> <span class="n">rhoM</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">*</span> <span class="n">math</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">thetaM_radians</span><span class="p">)</span>
            <span class="n">rhoMperp</span> <span class="o">=</span> <span class="n">rhoM</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">*</span> <span class="n">math</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">thetaM_radians</span><span class="p">)</span>

            <span class="c1"># /* If next slice is wrapped in phase, break */</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">thetaM</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">+</span> <span class="mf">180.0</span><span class="p">)</span> <span class="o">//</span> <span class="mf">360.0</span> <span class="o">!=</span> <span class="n">thetaM_phase_offset</span><span class="p">:</span>
                <span class="k">break</span>

            <span class="c1"># /* If next slice has different sign for rhoM, break */</span>
            <span class="k">if</span> <span class="n">math</span><span class="o">.</span><span class="n">copysign</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">rhoM</span><span class="p">[</span><span class="n">i</span><span class="p">])</span> <span class="o">!=</span> <span class="n">rhoM_sign</span><span class="p">:</span>
                <span class="k">break</span>

            <span class="k">if</span> <span class="n">rhoMpara</span> <span class="o">&lt;</span> <span class="n">mparalo</span><span class="p">:</span>
                <span class="n">mparalo</span> <span class="o">=</span> <span class="n">rhoMpara</span>
            <span class="k">if</span> <span class="n">rhoMpara</span> <span class="o">&gt;</span> <span class="n">mparahi</span><span class="p">:</span>
                <span class="n">mparahi</span> <span class="o">=</span> <span class="n">rhoMpara</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">mparahi</span> <span class="o">-</span> <span class="n">mparalo</span><span class="p">)</span> <span class="o">*</span> <span class="p">(</span><span class="n">dz</span> <span class="o">+</span> <span class="n">d</span><span class="p">[</span><span class="n">i</span><span class="p">])</span> <span class="o">&gt;</span> <span class="n">dA</span><span class="p">:</span>
                <span class="k">break</span>

            <span class="k">if</span> <span class="n">rhoMperp</span> <span class="o">&lt;</span> <span class="n">mperplo</span><span class="p">:</span>
                <span class="n">mperplo</span> <span class="o">=</span> <span class="n">rhoMperp</span>
            <span class="k">if</span> <span class="n">rhoMperp</span> <span class="o">&gt;</span> <span class="n">mperphi</span><span class="p">:</span>
                <span class="n">mperphi</span> <span class="o">=</span> <span class="n">rhoMperp</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">mperphi</span> <span class="o">-</span> <span class="n">mperplo</span><span class="p">)</span> <span class="o">*</span> <span class="p">(</span><span class="n">dz</span> <span class="o">+</span> <span class="n">d</span><span class="p">[</span><span class="n">i</span><span class="p">])</span> <span class="o">&gt;</span> <span class="n">dA</span><span class="p">:</span>
                <span class="k">break</span>

        <span class="k">assert</span> <span class="n">newi</span> <span class="o">&lt;</span> <span class="n">m</span>
        <span class="n">d</span><span class="p">[</span><span class="n">newi</span><span class="p">]</span> <span class="o">=</span> <span class="n">dz</span>
        <span class="k">if</span> <span class="n">dz</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">rho</span><span class="p">[</span><span class="n">newi</span><span class="p">]</span> <span class="o">=</span> <span class="n">rho</span><span class="p">[</span><span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span>
            <span class="n">irho</span><span class="p">[</span><span class="n">newi</span><span class="p">]</span> <span class="o">=</span> <span class="n">irho</span><span class="p">[</span><span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span>
            <span class="n">rhoM</span><span class="p">[</span><span class="n">newi</span><span class="p">]</span> <span class="o">=</span> <span class="n">rhoM</span><span class="p">[</span><span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span>
            <span class="n">thetaM</span><span class="p">[</span><span class="n">newi</span><span class="p">]</span> <span class="o">=</span> <span class="n">thetaM</span><span class="p">[</span><span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">rho</span><span class="p">[</span><span class="n">newi</span><span class="p">]</span> <span class="o">=</span> <span class="n">rhoarea</span> <span class="o">/</span> <span class="n">dz</span>
            <span class="n">irho</span><span class="p">[</span><span class="n">newi</span><span class="p">]</span> <span class="o">=</span> <span class="n">irhoarea</span> <span class="o">/</span> <span class="n">dz</span>
            <span class="n">mean_rhoMpara</span> <span class="o">=</span> <span class="n">rhoMpara_area</span> <span class="o">/</span> <span class="n">dz</span>
            <span class="n">mean_rhoMperp</span> <span class="o">=</span> <span class="n">rhoMperp_area</span> <span class="o">/</span> <span class="n">dz</span>
            <span class="n">mean_rhoM</span> <span class="o">=</span> <span class="n">math</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">mean_rhoMpara</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> <span class="n">mean_rhoMperp</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span> <span class="o">*</span> <span class="n">rhoM_sign</span>
            <span class="k">if</span> <span class="n">mean_rhoM</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="c1"># /* If rhoM is zero, then thetaM is meaningless: use plain average */</span>
                <span class="n">thetaM</span><span class="p">[</span><span class="n">newi</span><span class="p">]</span> <span class="o">=</span> <span class="n">thetaM_area</span> <span class="o">/</span> <span class="n">dz</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="c1"># /* Otherwise, calculate the mean thetaM</span>
                <span class="c1">#  * invert the sign of components if rhoM is negative, before atan2 */</span>
                <span class="n">thetaM_from_mean</span> <span class="o">=</span> <span class="n">math</span><span class="o">.</span><span class="n">atan2</span><span class="p">(</span><span class="n">mean_rhoMperp</span> <span class="o">*</span> <span class="n">rhoM_sign</span><span class="p">,</span> <span class="n">mean_rhoMpara</span> <span class="o">*</span> <span class="n">rhoM_sign</span><span class="p">)</span> <span class="o">*</span> <span class="mf">180.0</span> <span class="o">/</span> <span class="n">math</span><span class="o">.</span><span class="n">pi</span>
                <span class="n">thetaM_from_mean</span> <span class="o">+=</span> <span class="mf">360.0</span> <span class="o">*</span> <span class="n">thetaM_phase_offset</span>
                <span class="n">thetaM</span><span class="p">[</span><span class="n">newi</span><span class="p">]</span> <span class="o">=</span> <span class="n">thetaM_from_mean</span>
            <span class="n">rhoM</span><span class="p">[</span><span class="n">newi</span><span class="p">]</span> <span class="o">=</span> <span class="n">mean_rhoM</span>
        <span class="n">sigma</span><span class="p">[</span><span class="n">newi</span><span class="p">]</span> <span class="o">=</span> <span class="n">sigma</span><span class="p">[</span><span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span>

        <span class="n">newi</span> <span class="o">+=</span> <span class="mi">1</span>

    <span class="c1"># /* Save the last layer */</span>
    <span class="c1"># /* Last layer uses surface values */</span>
    <span class="n">rho</span><span class="p">[</span><span class="n">newi</span><span class="p">]</span> <span class="o">=</span> <span class="n">rho</span><span class="p">[</span><span class="n">n</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span>
    <span class="n">irho</span><span class="p">[</span><span class="n">newi</span><span class="p">]</span> <span class="o">=</span> <span class="n">irho</span><span class="p">[</span><span class="n">n</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span>
    <span class="n">rhoM</span><span class="p">[</span><span class="n">newi</span><span class="p">]</span> <span class="o">=</span> <span class="n">rhoM</span><span class="p">[</span><span class="n">n</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span>
    <span class="n">thetaM</span><span class="p">[</span><span class="n">newi</span><span class="p">]</span> <span class="o">=</span> <span class="n">thetaM</span><span class="p">[</span><span class="n">n</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span>
    <span class="c1"># /* No interface for final layer */</span>
    <span class="n">newi</span> <span class="o">+=</span> <span class="mi">1</span>

    <span class="k">return</span> <span class="n">newi</span></div>



<div class="viewcode-block" id="contract_by_area">
<a class="viewcode-back" href="../../../../refl1d.lib.python.contract_profile.html#refl1d.lib.numba.contract_by_area">[docs]</a>
<span class="k">def</span> <span class="nf">contract_by_area</span><span class="p">(</span><span class="n">d</span><span class="p">,</span> <span class="n">sigma</span><span class="p">,</span> <span class="n">rho</span><span class="p">,</span> <span class="n">irho</span><span class="p">,</span> <span class="n">dA</span><span class="p">):</span>
    <span class="n">n</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">d</span><span class="p">)</span>
    <span class="n">i</span> <span class="o">=</span> <span class="n">newi</span> <span class="o">=</span> <span class="mi">1</span>  <span class="c1"># /* Skip the substrate */</span>
    <span class="k">while</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">n</span><span class="p">:</span>
        <span class="c1"># /* Get ready for the next layer */</span>
        <span class="c1"># /* Accumulation of the first row happens in the inner loop */</span>
        <span class="n">dz</span> <span class="o">=</span> <span class="n">rhoarea</span> <span class="o">=</span> <span class="n">irhoarea</span> <span class="o">=</span> <span class="mf">0.0</span>
        <span class="n">rholo</span> <span class="o">=</span> <span class="n">rhohi</span> <span class="o">=</span> <span class="n">rho</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
        <span class="n">irholo</span> <span class="o">=</span> <span class="n">irhohi</span> <span class="o">=</span> <span class="n">irho</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>

        <span class="c1"># /* Accumulate slices into layer */</span>
        <span class="k">while</span> <span class="kc">True</span><span class="p">:</span>
            <span class="c1"># /* Accumulate next slice */</span>
            <span class="n">dz</span> <span class="o">+=</span> <span class="n">d</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
            <span class="n">rhoarea</span> <span class="o">+=</span> <span class="n">d</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">*</span> <span class="n">rho</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
            <span class="n">irhoarea</span> <span class="o">+=</span> <span class="n">d</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">*</span> <span class="n">irho</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>

            <span class="c1"># /* If no more slices or sigma != 0, break immediately */</span>
            <span class="n">i</span> <span class="o">+=</span> <span class="mi">1</span>
            <span class="k">if</span> <span class="n">i</span> <span class="o">==</span> <span class="n">n</span> <span class="ow">or</span> <span class="n">sigma</span><span class="p">[</span><span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span> <span class="o">!=</span> <span class="mf">0.0</span><span class="p">:</span>
                <span class="k">break</span>

            <span class="c1"># /* If next slice won&#39;t fit, break */</span>
            <span class="k">if</span> <span class="n">rho</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">rholo</span><span class="p">:</span>
                <span class="n">rholo</span> <span class="o">=</span> <span class="n">rho</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
            <span class="k">if</span> <span class="n">rho</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">rhohi</span><span class="p">:</span>
                <span class="n">rhohi</span> <span class="o">=</span> <span class="n">rho</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">rhohi</span> <span class="o">-</span> <span class="n">rholo</span><span class="p">)</span> <span class="o">*</span> <span class="p">(</span><span class="n">dz</span> <span class="o">+</span> <span class="n">d</span><span class="p">[</span><span class="n">i</span><span class="p">])</span> <span class="o">&gt;</span> <span class="n">dA</span><span class="p">:</span>
                <span class="k">break</span>

            <span class="k">if</span> <span class="n">irho</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">irholo</span><span class="p">:</span>
                <span class="n">irholo</span> <span class="o">=</span> <span class="n">irho</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
            <span class="k">if</span> <span class="n">irho</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">irhohi</span><span class="p">:</span>
                <span class="n">irhohi</span> <span class="o">=</span> <span class="n">irho</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">irhohi</span> <span class="o">-</span> <span class="n">irholo</span><span class="p">)</span> <span class="o">*</span> <span class="p">(</span><span class="n">dz</span> <span class="o">+</span> <span class="n">d</span><span class="p">[</span><span class="n">i</span><span class="p">])</span> <span class="o">&gt;</span> <span class="n">dA</span><span class="p">:</span>
                <span class="k">break</span>

        <span class="c1"># /* dz is only going to be zero if there is a forced break due to</span>
        <span class="c1"># * sigma, or if we are accumulating a substrate.  In either case,</span>
        <span class="c1"># * we want to accumulate the zero length layer</span>
        <span class="c1"># */</span>
        <span class="c1"># /* if (dz == 0) continue; */</span>

        <span class="c1"># /* Save the layer */</span>
        <span class="k">assert</span> <span class="n">newi</span> <span class="o">&lt;</span> <span class="n">n</span>
        <span class="n">d</span><span class="p">[</span><span class="n">newi</span><span class="p">]</span> <span class="o">=</span> <span class="n">dz</span>
        <span class="k">if</span> <span class="n">i</span> <span class="o">==</span> <span class="n">n</span><span class="p">:</span>
            <span class="c1"># /* printf(&quot;contract: adding final sld at %d\n&quot;,newi); */</span>
            <span class="c1"># /* Last layer uses surface values */</span>
            <span class="n">rho</span><span class="p">[</span><span class="n">newi</span><span class="p">]</span> <span class="o">=</span> <span class="n">rho</span><span class="p">[</span><span class="n">n</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span>
            <span class="n">irho</span><span class="p">[</span><span class="n">newi</span><span class="p">]</span> <span class="o">=</span> <span class="n">irho</span><span class="p">[</span><span class="n">n</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span>
            <span class="c1"># /* No interface for final layer */</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># /* Middle layers uses average values */</span>
            <span class="n">rho</span><span class="p">[</span><span class="n">newi</span><span class="p">]</span> <span class="o">=</span> <span class="n">rhoarea</span> <span class="o">/</span> <span class="n">dz</span>
            <span class="n">irho</span><span class="p">[</span><span class="n">newi</span><span class="p">]</span> <span class="o">=</span> <span class="n">irhoarea</span> <span class="o">/</span> <span class="n">dz</span>
            <span class="n">sigma</span><span class="p">[</span><span class="n">newi</span><span class="p">]</span> <span class="o">=</span> <span class="n">sigma</span><span class="p">[</span><span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span>
        <span class="c1"># /* First layer uses substrate values */</span>
        <span class="n">newi</span> <span class="o">+=</span> <span class="mi">1</span>

    <span class="k">return</span> <span class="n">newi</span></div>

</pre></div>

      </div>
      <div class="bottomnav" role="navigation" aria-label="Bottom">
      
        <p>
        <a class="uplink" href="../../../../index.html">Contents</a>
        </p>

      </div>

    <div class="footer" role="contentinfo">
      Created using <a href="https://www.sphinx-doc.org/">Sphinx</a> 8.1.3.
    </div>
  </body>
</html>