<!DOCTYPE html>

<html lang="en" data-content_root="../../">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>refl1d.resolution &#8212; Refl1D 0.7.7.post1533+gc6a0ac1 documentation</title>
    <link rel="stylesheet" type="text/css" href="../../_static/pygments.css?v=fa44fd50" />
    <link rel="stylesheet" type="text/css" href="../../_static/haiku-site.css?v=ccbba224" />
    <link rel="stylesheet" type="text/css" href="../../_static/plot_directive.css" />
    <script src="../../_static/documentation_options.js?v=132fb2fb"></script>
    <script src="../../_static/doctools.js?v=9bcbadda"></script>
    <script src="../../_static/sphinx_highlight.js?v=dc90522c"></script>
    <link rel="index" title="Index" href="../../genindex.html" />
    <link rel="search" title="Search" href="../../search.html" /> 
  </head><body>
      <div class="header" role="banner"><h1 class="heading"><a href="../../index.html">
          <span>Refl1D 0.7.7.post1533+gc6a0ac1 documentation</span></a></h1>
        <h2 class="heading"><span>refl1d.resolution</span></h2>
      </div>
      <div class="topnav" role="navigation" aria-label="Top">
      
        <p>
        <a class="uplink" href="../../index.html">Contents</a>
        </p>

      </div>
      <div class="content" role="main">
        
        
  <h1>Source code for refl1d.resolution</h1><div class="highlight"><pre>
<span></span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">Resolution calculations</span>

<span class="sd">&quot;&quot;&quot;</span>

<span class="kn">from</span> <span class="nn">numpy</span> <span class="kn">import</span> <span class="n">pi</span><span class="p">,</span> <span class="n">sqrt</span><span class="p">,</span> <span class="n">log</span><span class="p">,</span> <span class="n">degrees</span><span class="p">,</span> <span class="n">radians</span><span class="p">,</span> <span class="n">cos</span><span class="p">,</span> <span class="n">sin</span><span class="p">,</span> <span class="n">tan</span>
<span class="kn">from</span> <span class="nn">numpy</span> <span class="kn">import</span> <span class="n">arcsin</span> <span class="k">as</span> <span class="n">asin</span><span class="p">,</span> <span class="n">ceil</span>
<span class="kn">from</span> <span class="nn">numpy</span> <span class="kn">import</span> <span class="n">ones_like</span><span class="p">,</span> <span class="n">arange</span><span class="p">,</span> <span class="n">isscalar</span><span class="p">,</span> <span class="n">asarray</span><span class="p">,</span> <span class="n">hstack</span>
<span class="kn">from</span> <span class="nn">numpy</span> <span class="kn">import</span> <span class="n">float64</span>
<span class="kn">from</span> <span class="nn">typing</span> <span class="kn">import</span> <span class="n">TYPE_CHECKING</span>

<span class="k">if</span> <span class="n">TYPE_CHECKING</span><span class="p">:</span>
    <span class="kn">from</span> <span class="nn">numpy.typing</span> <span class="kn">import</span> <span class="n">ArrayLike</span>


<div class="viewcode-block" id="QL2T">
<a class="viewcode-back" href="../../refl1d.resolution.html#refl1d.resolution.QL2T">[docs]</a>
<span class="k">def</span> <span class="nf">QL2T</span><span class="p">(</span><span class="n">Q</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">L</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">    </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Compute angle from $Q$ and wavelength.</span>

<span class="sd">    .. math::</span>

<span class="sd">        \theta = \sin^{-1}( |Q| \lambda / 4 \pi )</span>

<span class="sd">    Returns $\theta$\ |deg|.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">Q</span><span class="p">,</span> <span class="n">L</span> <span class="o">=</span> <span class="n">asarray</span><span class="p">(</span><span class="n">Q</span><span class="p">,</span> <span class="s2">&quot;d&quot;</span><span class="p">),</span> <span class="n">asarray</span><span class="p">(</span><span class="n">L</span><span class="p">,</span> <span class="s2">&quot;d&quot;</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">degrees</span><span class="p">(</span><span class="n">asin</span><span class="p">(</span><span class="nb">abs</span><span class="p">(</span><span class="n">Q</span><span class="p">)</span> <span class="o">*</span> <span class="n">L</span> <span class="o">/</span> <span class="p">(</span><span class="mi">4</span> <span class="o">*</span> <span class="n">pi</span><span class="p">)))</span></div>



<div class="viewcode-block" id="QT2L">
<a class="viewcode-back" href="../../refl1d.resolution.html#refl1d.resolution.QT2L">[docs]</a>
<span class="k">def</span> <span class="nf">QT2L</span><span class="p">(</span><span class="n">Q</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">T</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">    </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Compute wavelength from $Q$ and angle.</span>

<span class="sd">    .. math::</span>

<span class="sd">        \lambda = 4 \pi \sin( \theta )/Q</span>

<span class="sd">    Returns $\lambda$\ |Ang|.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">Q</span><span class="p">,</span> <span class="n">T</span> <span class="o">=</span> <span class="n">asarray</span><span class="p">(</span><span class="n">Q</span><span class="p">,</span> <span class="s2">&quot;d&quot;</span><span class="p">),</span> <span class="n">radians</span><span class="p">(</span><span class="n">asarray</span><span class="p">(</span><span class="n">T</span><span class="p">,</span> <span class="s2">&quot;d&quot;</span><span class="p">))</span>
    <span class="k">return</span> <span class="mi">4</span> <span class="o">*</span> <span class="n">pi</span> <span class="o">*</span> <span class="n">sin</span><span class="p">(</span><span class="n">T</span><span class="p">)</span> <span class="o">/</span> <span class="n">Q</span></div>



<div class="viewcode-block" id="TL2Q">
<a class="viewcode-back" href="../../refl1d.resolution.html#refl1d.resolution.TL2Q">[docs]</a>
<span class="k">def</span> <span class="nf">TL2Q</span><span class="p">(</span><span class="n">T</span><span class="p">:</span> <span class="s2">&quot;ArrayLike&quot;</span><span class="p">,</span> <span class="n">L</span><span class="p">:</span> <span class="s2">&quot;ArrayLike&quot;</span><span class="p">):</span>
<span class="w">    </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Compute $Q$ from angle and wavelength.</span>

<span class="sd">    .. math::</span>

<span class="sd">        Q = 4 \pi \sin(\theta) / \lambda</span>

<span class="sd">    Returns $Q$ |1/Ang|</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">T</span><span class="p">,</span> <span class="n">L</span> <span class="o">=</span> <span class="n">radians</span><span class="p">(</span><span class="n">asarray</span><span class="p">(</span><span class="n">T</span><span class="p">,</span> <span class="s2">&quot;d&quot;</span><span class="p">)),</span> <span class="n">asarray</span><span class="p">(</span><span class="n">L</span><span class="p">,</span> <span class="s2">&quot;d&quot;</span><span class="p">)</span>
    <span class="k">return</span> <span class="mi">4</span> <span class="o">*</span> <span class="n">pi</span> <span class="o">*</span> <span class="n">sin</span><span class="p">(</span><span class="n">T</span><span class="p">)</span> <span class="o">/</span> <span class="n">L</span></div>



<span class="n">_FWHM_scale</span><span class="p">:</span> <span class="n">float64</span> <span class="o">=</span> <span class="n">sqrt</span><span class="p">(</span><span class="n">log</span><span class="p">(</span><span class="mi">256</span><span class="p">))</span>


<div class="viewcode-block" id="FWHM2sigma">
<a class="viewcode-back" href="../../refl1d.resolution.html#refl1d.resolution.FWHM2sigma">[docs]</a>
<span class="k">def</span> <span class="nf">FWHM2sigma</span><span class="p">(</span><span class="n">s</span><span class="p">:</span> <span class="s2">&quot;ArrayLike&quot;</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">asarray</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="s2">&quot;d&quot;</span><span class="p">)</span> <span class="o">/</span> <span class="n">_FWHM_scale</span></div>



<div class="viewcode-block" id="sigma2FWHM">
<a class="viewcode-back" href="../../refl1d.resolution.html#refl1d.resolution.sigma2FWHM">[docs]</a>
<span class="k">def</span> <span class="nf">sigma2FWHM</span><span class="p">(</span><span class="n">s</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">asarray</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="s2">&quot;d&quot;</span><span class="p">)</span> <span class="o">*</span> <span class="n">_FWHM_scale</span></div>



<div class="viewcode-block" id="dTdL2dQ">
<a class="viewcode-back" href="../../refl1d.resolution.html#refl1d.resolution.dTdL2dQ">[docs]</a>
<span class="k">def</span> <span class="nf">dTdL2dQ</span><span class="p">(</span><span class="n">T</span><span class="p">:</span> <span class="s2">&quot;ArrayLike&quot;</span><span class="p">,</span> <span class="n">dT</span><span class="p">:</span> <span class="s2">&quot;ArrayLike&quot;</span><span class="p">,</span> <span class="n">L</span><span class="p">:</span> <span class="s2">&quot;ArrayLike&quot;</span><span class="p">,</span> <span class="n">dL</span><span class="p">:</span> <span class="s2">&quot;ArrayLike&quot;</span><span class="p">):</span>
<span class="w">    </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Convert wavelength dispersion and angular divergence to $Q$ resolution.</span>

<span class="sd">    *T*, *dT*  (degrees) angle and FWHM angular divergence</span>
<span class="sd">    *L*, *dL*  (Angstroms) wavelength and FWHM wavelength dispersion</span>

<span class="sd">    Returns 1-\ $\sigma$ $\Delta Q$</span>

<span class="sd">    Given $Q = 4 \pi sin(\theta)/\lambda$, this follows directly from</span>
<span class="sd">    gaussian error propagation using</span>

<span class="sd">    ..math::</span>

<span class="sd">        \Delta Q^2</span>
<span class="sd">            &amp;= \left(\frac{\partial Q}{\partial \lambda}\right)^2\Delta\lambda^2</span>
<span class="sd">            + \left(\frac{\partial Q}{\partial \theta}\right)^2\Delta\theta^2</span>

<span class="sd">            &amp;= Q^2 \left(\frac{\Delta \lambda}{\lambda}\right)^2</span>
<span class="sd">            + Q^2 \left(\frac{\Delta \theta}{\tan \theta}\right)^2</span>

<span class="sd">            &amp;= Q^2 \left(\frac{\Delta \lambda}{\lambda}\right)^2</span>
<span class="sd">            + \left(\frac{4\pi\cos\theta\,\Delta\theta}{\lambda}\right)^2</span>

<span class="sd">    with the final form chosen to avoid cancellation at $Q=0$.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="c1"># Compute dQ from wavelength dispersion (dL) and angular divergence (dT)</span>
    <span class="n">T</span><span class="p">,</span> <span class="n">dT</span> <span class="o">=</span> <span class="n">radians</span><span class="p">(</span><span class="n">asarray</span><span class="p">(</span><span class="n">T</span><span class="p">,</span> <span class="n">float64</span><span class="p">)),</span> <span class="n">radians</span><span class="p">(</span><span class="n">asarray</span><span class="p">(</span><span class="n">dT</span><span class="p">,</span> <span class="n">float64</span><span class="p">))</span>
    <span class="n">L</span><span class="p">,</span> <span class="n">dL</span> <span class="o">=</span> <span class="n">asarray</span><span class="p">(</span><span class="n">L</span><span class="p">,</span> <span class="n">float64</span><span class="p">),</span> <span class="n">asarray</span><span class="p">(</span><span class="n">dL</span><span class="p">,</span> <span class="n">float64</span><span class="p">)</span>
    <span class="c1"># print T, dT, L, dL</span>
    <span class="n">dQ</span> <span class="o">=</span> <span class="p">(</span><span class="mi">4</span> <span class="o">*</span> <span class="n">pi</span> <span class="o">/</span> <span class="n">L</span><span class="p">)</span> <span class="o">*</span> <span class="n">sqrt</span><span class="p">((</span><span class="n">sin</span><span class="p">(</span><span class="n">T</span><span class="p">)</span> <span class="o">*</span> <span class="n">dL</span> <span class="o">/</span> <span class="n">L</span><span class="p">)</span> <span class="o">**</span> <span class="mi">2</span> <span class="o">+</span> <span class="p">(</span><span class="n">cos</span><span class="p">(</span><span class="n">T</span><span class="p">)</span> <span class="o">*</span> <span class="n">dT</span><span class="p">)</span> <span class="o">**</span> <span class="mi">2</span><span class="p">)</span>

    <span class="c1"># sqrt((dL/L)**2+(radians(dT)/tan(radians(T)))**2)*probe.Q</span>
    <span class="k">return</span> <span class="n">FWHM2sigma</span><span class="p">(</span><span class="n">dQ</span><span class="p">)</span></div>



<div class="viewcode-block" id="dQ_broadening">
<a class="viewcode-back" href="../../refl1d.resolution.html#refl1d.resolution.dQ_broadening">[docs]</a>
<span class="k">def</span> <span class="nf">dQ_broadening</span><span class="p">(</span><span class="n">dQ</span><span class="p">,</span> <span class="n">L</span><span class="p">,</span> <span class="n">T</span><span class="p">,</span> <span class="n">dT</span><span class="p">,</span> <span class="n">width</span><span class="p">):</span>
<span class="w">    </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Broaden an existing dQ by the given divergence.</span>

<span class="sd">    *dQ* |1/Ang|, with 1-\ $\sigma$ $Q$ resolution</span>
<span class="sd">    *L* |Ang|</span>
<span class="sd">    *T*, *dT* |deg|, with FWHM angular divergence</span>
<span class="sd">    *width* |deg|, with FWHM increased angular divergence</span>

<span class="sd">    The calculation is derived by substituting</span>
<span class="sd">    $\Delta\theta&#39; = \Delta\theta + \omega$ for sample broadening $\omega$</span>
<span class="sd">    into the resolution estimate</span>
<span class="sd">    $(\Delta Q/Q)^2 = (\Delta\lambda/\lambda)^2 + (\Delta\theta/\tan\theta)^2$.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">T</span><span class="p">,</span> <span class="n">dT</span> <span class="o">=</span> <span class="n">radians</span><span class="p">(</span><span class="n">asarray</span><span class="p">(</span><span class="n">T</span><span class="p">,</span> <span class="s2">&quot;d&quot;</span><span class="p">)),</span> <span class="n">FWHM2sigma</span><span class="p">(</span><span class="n">radians</span><span class="p">(</span><span class="n">asarray</span><span class="p">(</span><span class="n">dT</span><span class="p">,</span> <span class="s2">&quot;d&quot;</span><span class="p">)))</span>
    <span class="n">width</span> <span class="o">=</span> <span class="n">FWHM2sigma</span><span class="p">(</span><span class="n">radians</span><span class="p">(</span><span class="n">width</span><span class="p">))</span>
    <span class="n">dQsq</span> <span class="o">=</span> <span class="n">dQ</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> <span class="p">(</span><span class="mi">4</span> <span class="o">*</span> <span class="n">pi</span> <span class="o">/</span> <span class="n">L</span> <span class="o">*</span> <span class="n">cos</span><span class="p">(</span><span class="n">T</span><span class="p">))</span> <span class="o">**</span> <span class="mi">2</span> <span class="o">*</span> <span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="n">width</span> <span class="o">*</span> <span class="n">dT</span> <span class="o">+</span> <span class="n">width</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span>

    <span class="c1"># If width &lt; -dT, need to take abs(dQsq) before taking the sqrt</span>
    <span class="c1"># (focusing past zero)</span>
    <span class="k">return</span> <span class="n">sqrt</span><span class="p">(</span><span class="nb">abs</span><span class="p">(</span><span class="n">dQsq</span><span class="p">))</span></div>



<div class="viewcode-block" id="dQdT2dLoL">
<a class="viewcode-back" href="../../refl1d.resolution.html#refl1d.resolution.dQdT2dLoL">[docs]</a>
<span class="k">def</span> <span class="nf">dQdT2dLoL</span><span class="p">(</span><span class="n">Q</span><span class="p">,</span> <span class="n">dQ</span><span class="p">,</span> <span class="n">T</span><span class="p">,</span> <span class="n">dT</span><span class="p">):</span>
<span class="w">    </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Convert a calculated Q resolution and angular divergence to a</span>
<span class="sd">    wavelength dispersion.</span>

<span class="sd">    *Q*, *dQ* |1/Ang|  $Q$ and 1-\ $\sigma$ $Q$ resolution</span>
<span class="sd">    *T*, *dT* |deg| angle and FWHM angular divergence</span>

<span class="sd">    Returns FWHM $\Delta\lambda/\lambda$</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">T</span><span class="p">,</span> <span class="n">dT</span> <span class="o">=</span> <span class="n">radians</span><span class="p">(</span><span class="n">asarray</span><span class="p">(</span><span class="n">T</span><span class="p">,</span> <span class="s2">&quot;d&quot;</span><span class="p">)),</span> <span class="n">radians</span><span class="p">(</span><span class="n">asarray</span><span class="p">(</span><span class="n">dT</span><span class="p">,</span> <span class="s2">&quot;d&quot;</span><span class="p">))</span>
    <span class="n">Q</span><span class="p">,</span> <span class="n">dQ</span> <span class="o">=</span> <span class="n">asarray</span><span class="p">(</span><span class="n">Q</span><span class="p">,</span> <span class="s2">&quot;d&quot;</span><span class="p">),</span> <span class="n">asarray</span><span class="p">(</span><span class="n">dQ</span><span class="p">,</span> <span class="s2">&quot;d&quot;</span><span class="p">)</span>
    <span class="n">dQoQ</span> <span class="o">=</span> <span class="n">sigma2FWHM</span><span class="p">(</span><span class="n">dQ</span><span class="p">)</span> <span class="o">/</span> <span class="n">Q</span>
    <span class="n">dToT</span> <span class="o">=</span> <span class="n">dT</span> <span class="o">/</span> <span class="n">tan</span><span class="p">(</span><span class="n">T</span><span class="p">)</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">dQoQ</span> <span class="o">&lt;</span> <span class="n">dToT</span><span class="p">)</span><span class="o">.</span><span class="n">any</span><span class="p">():</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Cannot infer wavelength resolution: dQ is too small or dT is too large for some data points&quot;</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">sqrt</span><span class="p">(</span><span class="n">dQoQ</span><span class="o">**</span><span class="mi">2</span> <span class="o">-</span> <span class="n">dToT</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span></div>



<div class="viewcode-block" id="dQdL2dT">
<a class="viewcode-back" href="../../refl1d.resolution.html#refl1d.resolution.dQdL2dT">[docs]</a>
<span class="k">def</span> <span class="nf">dQdL2dT</span><span class="p">(</span><span class="n">Q</span><span class="p">,</span> <span class="n">dQ</span><span class="p">,</span> <span class="n">L</span><span class="p">,</span> <span class="n">dL</span><span class="p">):</span>
<span class="w">    </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Convert a calculated Q resolution and wavelength dispersion to</span>
<span class="sd">    angular divergence.</span>

<span class="sd">    *Q*, *dQ* |1/Ang|  $Q$ and 1-\ $\sigma$ $Q$ resolution</span>
<span class="sd">    *L*, *dL* |deg| angle and FWHM angular divergence</span>

<span class="sd">    Returns FWHM \Delta\theta$</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">L</span><span class="p">,</span> <span class="n">dL</span> <span class="o">=</span> <span class="n">asarray</span><span class="p">(</span><span class="n">L</span><span class="p">,</span> <span class="s2">&quot;d&quot;</span><span class="p">),</span> <span class="n">asarray</span><span class="p">(</span><span class="n">dL</span><span class="p">,</span> <span class="s2">&quot;d&quot;</span><span class="p">)</span>
    <span class="n">Q</span><span class="p">,</span> <span class="n">dQ</span> <span class="o">=</span> <span class="n">asarray</span><span class="p">(</span><span class="n">Q</span><span class="p">,</span> <span class="s2">&quot;d&quot;</span><span class="p">),</span> <span class="n">asarray</span><span class="p">(</span><span class="n">dQ</span><span class="p">,</span> <span class="s2">&quot;d&quot;</span><span class="p">)</span>
    <span class="n">T</span> <span class="o">=</span> <span class="n">radians</span><span class="p">(</span><span class="n">QL2T</span><span class="p">(</span><span class="n">Q</span><span class="p">,</span> <span class="n">L</span><span class="p">))</span>
    <span class="n">dQoQ</span> <span class="o">=</span> <span class="n">sigma2FWHM</span><span class="p">(</span><span class="n">dQ</span><span class="p">)</span> <span class="o">/</span> <span class="n">Q</span>
    <span class="n">dLoL</span> <span class="o">=</span> <span class="n">dL</span> <span class="o">/</span> <span class="n">L</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">dQoQ</span> <span class="o">&lt;</span> <span class="n">dLoL</span><span class="p">)</span><span class="o">.</span><span class="n">any</span><span class="p">():</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Cannot infer angular resolution: dQ is too small or dL is too large for some data points&quot;</span><span class="p">)</span>
    <span class="n">dT</span> <span class="o">=</span> <span class="n">degrees</span><span class="p">(</span><span class="n">sqrt</span><span class="p">(</span><span class="n">dQoQ</span><span class="o">**</span><span class="mi">2</span> <span class="o">-</span> <span class="n">dLoL</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span> <span class="o">*</span> <span class="n">tan</span><span class="p">(</span><span class="n">T</span><span class="p">))</span>
    <span class="k">return</span> <span class="n">dT</span></div>



<span class="n">Plancks_constant</span> <span class="o">=</span> <span class="mf">6.62618e-27</span>  <span class="c1"># Planck constant (erg*sec)</span>
<span class="n">neutron_mass</span> <span class="o">=</span> <span class="mf">1.67495e-24</span>  <span class="c1"># neutron mass (g)</span>


<div class="viewcode-block" id="TOF2L">
<a class="viewcode-back" href="../../refl1d.resolution.html#refl1d.resolution.TOF2L">[docs]</a>
<span class="k">def</span> <span class="nf">TOF2L</span><span class="p">(</span><span class="n">d_moderator</span><span class="p">,</span> <span class="n">TOF</span><span class="p">):</span>
<span class="w">    </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Convert neutron time-of-flight to wavelength.</span>

<span class="sd">    .. math::</span>

<span class="sd">        \lambda = (t/d) (h/n_m)</span>

<span class="sd">    where:</span>

<span class="sd">        | $\lambda$ is wavelength in |Ang|</span>
<span class="sd">        | $t$ is time-of-flight in $u$\s</span>
<span class="sd">        | $h$ is Planck&#39;s constant in erg seconds</span>
<span class="sd">        | $n_m$ is the neutron mass in g</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">TOF</span> <span class="o">*</span> <span class="p">(</span><span class="n">Plancks_constant</span> <span class="o">/</span> <span class="n">neutron_mass</span> <span class="o">/</span> <span class="n">d_moderator</span><span class="p">)</span></div>



<div class="viewcode-block" id="bins">
<a class="viewcode-back" href="../../refl1d.resolution.html#refl1d.resolution.bins">[docs]</a>
<span class="k">def</span> <span class="nf">bins</span><span class="p">(</span><span class="n">low</span><span class="p">,</span> <span class="n">high</span><span class="p">,</span> <span class="n">dLoL</span><span class="p">):</span>
<span class="w">    </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Return bin centers from low to high preserving a fixed resolution.</span>

<span class="sd">    *low*, *high* are the minimum and maximum wavelength.</span>
<span class="sd">    *dLoL* is the desired resolution FWHM $\Delta\lambda/\lambda$ for the bins.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">step</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">+</span> <span class="n">dLoL</span>
    <span class="n">n</span> <span class="o">=</span> <span class="n">ceil</span><span class="p">(</span><span class="n">log</span><span class="p">(</span><span class="n">high</span> <span class="o">/</span> <span class="n">low</span><span class="p">)</span> <span class="o">/</span> <span class="n">log</span><span class="p">(</span><span class="n">step</span><span class="p">))</span>
    <span class="n">edges</span> <span class="o">=</span> <span class="n">low</span> <span class="o">*</span> <span class="n">step</span> <span class="o">**</span> <span class="n">arange</span><span class="p">(</span><span class="n">n</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
    <span class="n">L</span> <span class="o">=</span> <span class="p">(</span><span class="n">edges</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="n">edges</span><span class="p">[</span><span class="mi">1</span><span class="p">:])</span> <span class="o">/</span> <span class="mi">2</span>
    <span class="k">return</span> <span class="n">L</span></div>



<div class="viewcode-block" id="binwidths">
<a class="viewcode-back" href="../../refl1d.resolution.html#refl1d.resolution.binwidths">[docs]</a>
<span class="k">def</span> <span class="nf">binwidths</span><span class="p">(</span><span class="n">L</span><span class="p">):</span>
<span class="w">    </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Determine the wavelength dispersion from bin centers *L*.</span>

<span class="sd">    The wavelength dispersion $\Delta\lambda$ is just the difference</span>
<span class="sd">    between consecutive bin edges, so:</span>

<span class="sd">    .. math::</span>

<span class="sd">        \Delta L_i  = E_{i+1}-E_{i}</span>
<span class="sd">                    = (1+\omega) E_i - E_i</span>
<span class="sd">                    = \omega E_i</span>
<span class="sd">                    = \frac{2 \omega}{2+\omega} L_i</span>

<span class="sd">    where $E$ and $\omega$ are as defined in :func:`binedges`.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">L</span> <span class="o">=</span> <span class="n">asarray</span><span class="p">(</span><span class="n">L</span><span class="p">,</span> <span class="s2">&quot;d&quot;</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">L</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">L</span><span class="p">[</span><span class="mi">0</span><span class="p">]:</span>
        <span class="n">dLoL</span> <span class="o">=</span> <span class="n">L</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">/</span> <span class="n">L</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="mi">1</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">dLoL</span> <span class="o">=</span> <span class="n">L</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">/</span> <span class="n">L</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="mi">1</span>
    <span class="n">dL</span> <span class="o">=</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">dLoL</span> <span class="o">/</span> <span class="p">(</span><span class="mi">2</span> <span class="o">+</span> <span class="n">dLoL</span><span class="p">)</span> <span class="o">*</span> <span class="n">L</span>
    <span class="k">return</span> <span class="n">dL</span></div>



<div class="viewcode-block" id="binedges">
<a class="viewcode-back" href="../../refl1d.resolution.html#refl1d.resolution.binedges">[docs]</a>
<span class="k">def</span> <span class="nf">binedges</span><span class="p">(</span><span class="n">L</span><span class="p">):</span>
<span class="w">    </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Construct bin edges *E* from bin centers *L*.</span>

<span class="sd">    Assuming fixed $\omega = \Delta\lambda/\lambda$ in the bins, the</span>
<span class="sd">    edges will be spaced logarithmically at:</span>

<span class="sd">    .. math::</span>

<span class="sd">        E_0     &amp;= \min \lambda \\</span>
<span class="sd">        E_{i+1} &amp;= E_i + \omega E_i = E_i (1+\omega)</span>

<span class="sd">    with centers $L$ half way between the edges:</span>

<span class="sd">    .. math::</span>

<span class="sd">        L_i = (E_i+E_{i+1})/2</span>
<span class="sd">            = (E_i + E_i (1+\omega))/2</span>
<span class="sd">            = E_i (2 + \omega)/2</span>

<span class="sd">    Solving for $E_i$, we can recover the edges from the centers:</span>

<span class="sd">    .. math::</span>

<span class="sd">        E_i = L_i \frac{2}{2+\omega}</span>

<span class="sd">    The final edge, $E_{n+1}$, does not have a corresponding center</span>
<span class="sd">    $L_{n+1}$ so we must determine it from the previous edge $E_n$:</span>

<span class="sd">    .. math::</span>

<span class="sd">        E_{n+1} = L_n \frac{2}{2+\omega}(1+\omega)</span>

<span class="sd">    The fixed $\omega$ can be retrieved from the ratio of any pair</span>
<span class="sd">    of bin centers using:</span>

<span class="sd">    .. math::</span>

<span class="sd">        \frac{L_{i+1}}{L_i} = \frac{ (E_{i+2}+E_{i+1})/2 }{ (E_{i+1}+E_i)/2 }</span>
<span class="sd">                          = \frac{ (E_{i+1}(1+\omega)+E_{i+1} }</span>
<span class="sd">                                  { (E_i(1+\omega)+E_i }</span>
<span class="sd">                          = \frac{E_{i+1}}{E_i}</span>
<span class="sd">                          = \frac{E_i(1+\omega)}{E_i} = 1 + \omega</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">L</span> <span class="o">=</span> <span class="n">asarray</span><span class="p">(</span><span class="n">L</span><span class="p">,</span> <span class="s2">&quot;d&quot;</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">L</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">L</span><span class="p">[</span><span class="mi">0</span><span class="p">]:</span>
        <span class="n">dLoL</span> <span class="o">=</span> <span class="n">L</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">/</span> <span class="n">L</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="mi">1</span>
        <span class="n">last</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">+</span> <span class="n">dLoL</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">dLoL</span> <span class="o">=</span> <span class="n">L</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">/</span> <span class="n">L</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="mi">1</span>
        <span class="n">last</span> <span class="o">=</span> <span class="mf">1.0</span> <span class="o">/</span> <span class="p">(</span><span class="mi">1</span> <span class="o">+</span> <span class="n">dLoL</span><span class="p">)</span>
    <span class="n">E</span> <span class="o">=</span> <span class="n">L</span> <span class="o">*</span> <span class="mi">2</span> <span class="o">/</span> <span class="p">(</span><span class="mi">2</span> <span class="o">+</span> <span class="n">dLoL</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">hstack</span><span class="p">((</span><span class="n">E</span><span class="p">,</span> <span class="n">E</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">*</span> <span class="n">last</span><span class="p">))</span></div>



<div class="viewcode-block" id="divergence">
<a class="viewcode-back" href="../../refl1d.resolution.html#refl1d.resolution.divergence">[docs]</a>
<span class="k">def</span> <span class="nf">divergence</span><span class="p">(</span><span class="n">T</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">slits</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">distance</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">sample_width</span><span class="o">=</span><span class="mf">1e10</span><span class="p">,</span> <span class="n">sample_broadening</span><span class="o">=</span><span class="mi">0</span><span class="p">):</span>
<span class="w">    </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Calculate divergence due to slit and sample geometry.</span>

<span class="sd">    :Parameters:</span>
<span class="sd">        *T*         : float OR [float] | degrees</span>
<span class="sd">            incident angles</span>
<span class="sd">        *slits*     : float OR (float, float) | mm</span>
<span class="sd">            s1, s2 slit openings for slit 1 and slit 2</span>
<span class="sd">        *distance*  : (float, float) | mm</span>
<span class="sd">            d1, d2 distance from sample to slit 1 and slit 2</span>
<span class="sd">        *sample_width*      : float | mm</span>
<span class="sd">            w, width of the sample</span>
<span class="sd">        *sample_broadening* : float | degrees FWHM</span>
<span class="sd">            additional divergence caused by sample</span>

<span class="sd">    :Returns:</span>
<span class="sd">        *dT*  : float OR [float] | degrees FWHM</span>
<span class="sd">            calculated angular divergence</span>

<span class="sd">    **Algorithm:**</span>

<span class="sd">    The divergence is based on the slit openings and the distance between</span>
<span class="sd">    the slits.  For very small samples, where the slit opening is larger</span>
<span class="sd">    than the width of the sample across the beam, the sample itself acts</span>
<span class="sd">    like the second slit.</span>

<span class="sd">    First find $p$, the projection of the beam on the sample:</span>

<span class="sd">    .. math::</span>

<span class="sd">        p &amp;= w \sin\left(\frac{\pi}{180}\theta\right)</span>

<span class="sd">    Depending on whether $p$ is larger than $s_2$, determine the slit</span>
<span class="sd">    divergence $\Delta\theta_d$ in radians:</span>

<span class="sd">    .. math::</span>

<span class="sd">        \Delta\theta_d &amp;= \left\{</span>
<span class="sd">          \begin{array}{ll}</span>
<span class="sd">            \frac{1}{2}\frac{s_1+s_2}{d_1-d_2} &amp; \mbox{if } p \geq s_2 \\</span>
<span class="sd">            \frac{1}{2}\frac{s_1+p}{d_1}       &amp; \mbox{if } p &lt; s_2</span>
<span class="sd">          \end{array}</span>
<span class="sd">        \right.</span>

<span class="sd">    In addition to the slit divergence, we need to add in any sample</span>
<span class="sd">    broadening $\Delta\theta_s$ returning the total divergence in degrees:</span>

<span class="sd">    .. math::</span>

<span class="sd">        \Delta\theta &amp;= \frac{180}{\pi} \Delta\theta_d + \Delta\theta_s</span>

<span class="sd">    Reversing this equation, the sample broadening contribution can</span>
<span class="sd">    be measured from the full width at half maximum of the rocking</span>
<span class="sd">    curve, $B$, measured in degrees at a particular angle and slit</span>
<span class="sd">    opening:</span>

<span class="sd">    .. math::</span>

<span class="sd">        \Delta\theta_s = B - \frac{180}{\pi}\Delta\theta_d</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># TODO: update from reductus to handle four slits</span>
    <span class="c1"># TODO: check that the formula is correct for T=0 =&gt; dT = s1 / d1</span>
    <span class="c1"># TODO: add sample_offset and compute full footprint</span>
    <span class="n">d1</span><span class="p">,</span> <span class="n">d2</span> <span class="o">=</span> <span class="n">distance</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="n">s1</span><span class="p">,</span> <span class="n">s2</span> <span class="o">=</span> <span class="n">slits</span>
    <span class="k">except</span> <span class="ne">TypeError</span><span class="p">:</span>
        <span class="n">s1</span> <span class="o">=</span> <span class="n">s2</span> <span class="o">=</span> <span class="n">slits</span>

    <span class="c1"># Compute FWHM angular divergence dT from the slits in degrees</span>
    <span class="n">dT</span> <span class="o">=</span> <span class="n">degrees</span><span class="p">(</span><span class="mf">0.5</span> <span class="o">*</span> <span class="p">(</span><span class="n">s1</span> <span class="o">+</span> <span class="n">s2</span><span class="p">)</span> <span class="o">/</span> <span class="p">(</span><span class="n">d1</span> <span class="o">-</span> <span class="n">d2</span><span class="p">))</span>

    <span class="c1"># For small samples, use the sample projection instead.</span>
    <span class="n">sample_s</span> <span class="o">=</span> <span class="n">sample_width</span> <span class="o">*</span> <span class="n">sin</span><span class="p">(</span><span class="n">radians</span><span class="p">(</span><span class="n">T</span><span class="p">))</span>
    <span class="k">if</span> <span class="n">isscalar</span><span class="p">(</span><span class="n">sample_s</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">sample_s</span> <span class="o">&lt;</span> <span class="n">s2</span><span class="p">:</span>
            <span class="n">dT</span> <span class="o">=</span> <span class="n">degrees</span><span class="p">(</span><span class="mf">0.5</span> <span class="o">*</span> <span class="p">(</span><span class="n">s1</span> <span class="o">+</span> <span class="n">sample_s</span><span class="p">)</span> <span class="o">/</span> <span class="n">d1</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">idx</span> <span class="o">=</span> <span class="n">sample_s</span> <span class="o">&lt;</span> <span class="n">s2</span>
        <span class="c1"># print s1, s2, d1, d2, T, dT, sample_s</span>
        <span class="n">s1</span> <span class="o">=</span> <span class="n">ones_like</span><span class="p">(</span><span class="n">sample_s</span><span class="p">)</span> <span class="o">*</span> <span class="n">s1</span>
        <span class="n">dT</span> <span class="o">=</span> <span class="n">ones_like</span><span class="p">(</span><span class="n">sample_s</span><span class="p">)</span> <span class="o">*</span> <span class="n">dT</span>
        <span class="n">dT</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span> <span class="o">=</span> <span class="n">degrees</span><span class="p">(</span><span class="mf">0.5</span> <span class="o">*</span> <span class="p">(</span><span class="n">s1</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span> <span class="o">+</span> <span class="n">sample_s</span><span class="p">[</span><span class="n">idx</span><span class="p">])</span> <span class="o">/</span> <span class="n">d1</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">dT</span> <span class="o">+</span> <span class="n">sample_broadening</span></div>



<div class="viewcode-block" id="slit_widths">
<a class="viewcode-back" href="../../refl1d.resolution.html#refl1d.resolution.slit_widths">[docs]</a>
<span class="k">def</span> <span class="nf">slit_widths</span><span class="p">(</span><span class="n">T</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">slits_at_Tlo</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">Tlo</span><span class="o">=</span><span class="mi">90</span><span class="p">,</span> <span class="n">Thi</span><span class="o">=</span><span class="mi">90</span><span class="p">,</span> <span class="n">slits_below</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">slits_above</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Compute the slit widths for the standard scanning reflectometer</span>
<span class="sd">    fixed-opening-fixed geometry.</span>

<span class="sd">    :Parameters:</span>
<span class="sd">        *T* : [float] | degrees</span>
<span class="sd">            Specular measurement angles.</span>
<span class="sd">        *Tlo*, *Thi* : float | degrees</span>
<span class="sd">            Start and end of the opening region.  The default if *Tlo* is</span>
<span class="sd">            not specified is to use fixed slits at *slits_below* for all</span>
<span class="sd">            angles.</span>
<span class="sd">        *slits_below*, *slits_above* : float OR [float, float] | mm</span>
<span class="sd">            Slits outside opening region.  The default is to use the</span>
<span class="sd">            values of the slits at the ends of the opening region.</span>
<span class="sd">        *slits_at_Tlo* : float OR [float, float] | mm</span>
<span class="sd">            Slits at the start of the opening region.</span>

<span class="sd">    :Returns:</span>
<span class="sd">        *s1*, *s2* : [float] | mm</span>
<span class="sd">            Slit widths for each theta.</span>

<span class="sd">    Slits are assumed to be fixed below angle *Tlo* and above angle *Thi*,</span>
<span class="sd">    and opening at a constant dT/T between them.</span>

<span class="sd">    Slit openings are defined by a tuple (s1, s2) or constant s=s1=s2.</span>
<span class="sd">    With no *Tlo*, the slits are fixed with widths defined by *slits_below*,</span>
<span class="sd">    which defaults to *slits_at_Tlo*.  With no *Thi*, slits are continuously</span>
<span class="sd">    opening above *Tlo*.</span>

<span class="sd">    .. Note::</span>
<span class="sd">         This function works equally well if angles are measured in</span>
<span class="sd">         radians and/or slits are measured in inches.</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="c1"># Slits at T&lt;Tlo</span>
    <span class="k">if</span> <span class="n">slits_below</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">slits_below</span> <span class="o">=</span> <span class="n">slits_at_Tlo</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="n">b1</span><span class="p">,</span> <span class="n">b2</span> <span class="o">=</span> <span class="n">slits_below</span>
    <span class="k">except</span> <span class="ne">TypeError</span><span class="p">:</span>
        <span class="n">b1</span> <span class="o">=</span> <span class="n">b2</span> <span class="o">=</span> <span class="n">slits_below</span>
    <span class="n">s1</span> <span class="o">=</span> <span class="n">ones_like</span><span class="p">(</span><span class="n">T</span><span class="p">)</span> <span class="o">*</span> <span class="n">b1</span>
    <span class="n">s2</span> <span class="o">=</span> <span class="n">ones_like</span><span class="p">(</span><span class="n">T</span><span class="p">)</span> <span class="o">*</span> <span class="n">b2</span>

    <span class="c1"># Slits at Tlo&lt;=T&lt;=Thi</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="n">m1</span><span class="p">,</span> <span class="n">m2</span> <span class="o">=</span> <span class="n">slits_at_Tlo</span>
    <span class="k">except</span> <span class="ne">TypeError</span><span class="p">:</span>
        <span class="n">m1</span> <span class="o">=</span> <span class="n">m2</span> <span class="o">=</span> <span class="n">slits_at_Tlo</span>
    <span class="n">idx</span> <span class="o">=</span> <span class="nb">abs</span><span class="p">(</span><span class="n">T</span><span class="p">)</span> <span class="o">&gt;=</span> <span class="n">Tlo</span>
    <span class="n">s1</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span> <span class="o">=</span> <span class="n">m1</span> <span class="o">*</span> <span class="n">T</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span> <span class="o">/</span> <span class="n">Tlo</span>
    <span class="n">s2</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span> <span class="o">=</span> <span class="n">m2</span> <span class="o">*</span> <span class="n">T</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span> <span class="o">/</span> <span class="n">Tlo</span>

    <span class="c1"># Slits at T &gt; Thi</span>
    <span class="k">if</span> <span class="n">slits_above</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">slits_above</span> <span class="o">=</span> <span class="n">m1</span> <span class="o">*</span> <span class="n">Thi</span> <span class="o">/</span> <span class="n">Tlo</span><span class="p">,</span> <span class="n">m2</span> <span class="o">*</span> <span class="n">Thi</span> <span class="o">/</span> <span class="n">Tlo</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="n">t1</span><span class="p">,</span> <span class="n">t2</span> <span class="o">=</span> <span class="n">slits_above</span>
    <span class="k">except</span> <span class="ne">TypeError</span><span class="p">:</span>
        <span class="n">t1</span> <span class="o">=</span> <span class="n">t2</span> <span class="o">=</span> <span class="n">slits_above</span>
    <span class="n">idx</span> <span class="o">=</span> <span class="nb">abs</span><span class="p">(</span><span class="n">T</span><span class="p">)</span> <span class="o">&gt;</span> <span class="n">Thi</span>
    <span class="n">s1</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span> <span class="o">=</span> <span class="n">t1</span>
    <span class="n">s2</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span> <span class="o">=</span> <span class="n">t2</span>

    <span class="k">return</span> <span class="n">s1</span><span class="p">,</span> <span class="n">s2</span></div>



<span class="sd">&#39;&#39;&#39;</span>
<span class="sd">def resolution(Q=None, s=None, d=None, L=None, dLoL=None, Tlo=None, Thi=None,</span>
<span class="sd">               s_below=None, s_above=None,</span>
<span class="sd">               broadening=0, sample_width=1e10, sample_distance=0):</span>
<span class="sd">    &quot;&quot;&quot;</span>
<span class="sd">    Compute the resolution for Q on scanning reflectometers.</span>

<span class="sd">    broadening is the sample warp contribution to angular divergence, as</span>
<span class="sd">    measured by a rocking curve.  The value should be w - (s1+s2)/(2*d)</span>
<span class="sd">    where w is the full-width at half maximum of the rocking curve.</span>

<span class="sd">    For itty-bitty samples, provide a sample width w and sample distance ds</span>
<span class="sd">    from slit 2 to the sample.  If s_sample = sin(T)*w is smaller than s2</span>
<span class="sd">    for some T, then that will be used for the calculation of dT instead.</span>

<span class="sd">    &quot;&quot;&quot;</span>
<span class="sd">    T = QL2T(Q=Q, L=L)</span>
<span class="sd">    slits = slit_widths(T=T, s=s, Tlo=Tlo, Thi=Thi)</span>
<span class="sd">    dT = divergence(T=T, slits=slits, sample_width=sample_width,</span>
<span class="sd">                    sample_distance=sample_distance) + broadening</span>
<span class="sd">    Q, dQ = Qresolution(L, dLoL*L, T, dT)</span>
<span class="sd">    return FWHM2sigma(dQ)</span>


<span class="sd">def demo():</span>
<span class="sd">    from numpy import linspace, exp, real, conj, sin, radians</span>
<span class="sd">    import matplotlib.pyplot as plt</span>

<span class="sd">    # Values from volfrac example in garefl</span>
<span class="sd">    T = linspace(0, 9, 140)</span>
<span class="sd">    Q = 4*pi*sin(radians(T))/5.0042</span>
<span class="sd">    dQ = resolution(Q, s=0.21, Tlo=0.35, d=1890., L=5.0042, dLoL=0.009)</span>
<span class="sd">    #plt.plot(Q, dQ)</span>

<span class="sd">    # Fresnel reflectivity for silicon</span>
<span class="sd">    rho, sigma=2.07, 5</span>
<span class="sd">    kz=Q/2</span>
<span class="sd">    f = sqrt(kz**2 - 4*pi*rho*1e-6 + 0j)</span>
<span class="sd">    r = (kz-f)/(kz+f)*exp(-2*sigma**2*kz*f)</span>
<span class="sd">    r[abs(kz)&lt;1e-10] = -1</span>
<span class="sd">    R = real(r*conj(r))</span>
<span class="sd">    plt.errorbar(Q, R, xerr=dQ, fmt=&#39;,r&#39;, capsize=0)</span>
<span class="sd">    plt.grid(True)</span>
<span class="sd">    plt.semilogy(Q, R, &#39;,b&#39;)</span>

<span class="sd">    plt.show()</span>


<span class="sd">def demo2():</span>
<span class="sd">    import numpy as np</span>
<span class="sd">    import matplotlib.pyplot as plt</span>

<span class="sd">    Q, R, dR = np.loadtxt(&#39;ga128.refl.mce&#39;).T</span>
<span class="sd">    dQ = resolution(Q, s=0.154, Tlo=0.36, d=1500., L=4.75, dLoL=0.02)</span>
<span class="sd">    plt.errorbar(Q, R, xerr=dQ, yerr=dR, fmt=&#39;,r&#39;, capsize=0)</span>
<span class="sd">    plt.grid(True)</span>
<span class="sd">    plt.semilogy(Q, R, &#39;,b&#39;)</span>
<span class="sd">    plt.show()</span>


<span class="sd">if __name__ == &quot;__main__&quot;:</span>
<span class="sd">    demo2()</span>
<span class="sd">&#39;&#39;&#39;</span>
</pre></div>

      </div>
      <div class="bottomnav" role="navigation" aria-label="Bottom">
      
        <p>
        <a class="uplink" href="../../index.html">Contents</a>
        </p>

      </div>

    <div class="footer" role="contentinfo">
      Created using <a href="https://www.sphinx-doc.org/">Sphinx</a> 8.1.3.
    </div>
  </body>
</html>