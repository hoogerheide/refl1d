<!DOCTYPE html>

<html lang="en" data-content_root="../../">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>refl1d.instrument &#8212; Refl1D 0.7.7.post1533+gc6a0ac1 documentation</title>
    <link rel="stylesheet" type="text/css" href="../../_static/pygments.css?v=fa44fd50" />
    <link rel="stylesheet" type="text/css" href="../../_static/haiku-site.css?v=ccbba224" />
    <link rel="stylesheet" type="text/css" href="../../_static/plot_directive.css" />
    <script src="../../_static/documentation_options.js?v=132fb2fb"></script>
    <script src="../../_static/doctools.js?v=9bcbadda"></script>
    <script src="../../_static/sphinx_highlight.js?v=dc90522c"></script>
    <link rel="index" title="Index" href="../../genindex.html" />
    <link rel="search" title="Search" href="../../search.html" /> 
  </head><body>
      <div class="header" role="banner"><h1 class="heading"><a href="../../index.html">
          <span>Refl1D 0.7.7.post1533+gc6a0ac1 documentation</span></a></h1>
        <h2 class="heading"><span>refl1d.instrument</span></h2>
      </div>
      <div class="topnav" role="navigation" aria-label="Top">
      
        <p>
        <a class="uplink" href="../../index.html">Contents</a>
        </p>

      </div>
      <div class="content" role="main">
        
        
  <h1>Source code for refl1d.instrument</h1><div class="highlight"><pre>
<span></span><span class="c1"># This program is in the public domain</span>
<span class="c1"># Author: Paul Kienzle</span>
<span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">Reflectometry instrument definitions.</span>

<span class="sd">An instrument definition contains all the information necessary to compute</span>
<span class="sd">the resolution for a measurement.  See :mod:`resolution` for details.</span>

<span class="sd">This module is intended to help define new instrument loaders</span>

<span class="sd">Scanning Reflectometers</span>
<span class="sd">=======================</span>

<span class="sd">:mod:`refl1d.instrument` (this module) defines two instrument types:</span>
<span class="sd">:class:`Monochromatic` and :class:`Pulsed`. These represent</span>
<span class="sd">generic scanning and time of flight instruments, respectively.</span>

<span class="sd">To perform a simulation or load a data set, a measurement geometry must</span>
<span class="sd">be defined.  In the following example, we set up the geometry for a</span>
<span class="sd">pretend instrument SP:2. The complete geometry needs to include information</span>
<span class="sd">to calculate wavelength resolution (wavelength and wavelength dispersion)</span>
<span class="sd">as well as angular resolution (slit distances and openings, and perhaps</span>
<span class="sd">sample size and sample warp).  In this case, we are using a scanning</span>
<span class="sd">monochromatic instrument with slits of 0.1 mm below 0.5\ |deg| and</span>
<span class="sd">opening slits  above 0.5\ |deg| starting at 0.2 mm.  The monochromatic</span>
<span class="sd">instrument assumes a fixed $\Delta \theta / \theta$ while opening.</span>

<span class="sd">    &gt;&gt;&gt; from refl1d.names import *</span>
<span class="sd">    &gt;&gt;&gt; geometry = Monochromatic(instrument=&quot;SP:2&quot;, radiation=&quot;neutron&quot;,</span>
<span class="sd">    ...    wavelength=5.0042, dLoL=0.009, d_s1=230+1856, d_s2=230,</span>
<span class="sd">    ...    Tlo=0.5, slits_at_Tlo=0.2, slits_below=0.1)</span>

<span class="sd">This instrument can be used to  a data file, or generate a</span>
<span class="sd">measurement probe for use in modeling or to read in a previously</span>
<span class="sd">measured data set or generate a probe for simulation:</span>

<span class="sd">    &gt;&gt;&gt; from numpy import linspace, loadtxt</span>
<span class="sd">    &gt;&gt;&gt; datafile = sample_data(&#39;10ndt001.refl&#39;)</span>
<span class="sd">    &gt;&gt;&gt; Q, R, dR = loadtxt(datafile).T</span>
<span class="sd">    &gt;&gt;&gt; probe = geometry.probe(Q=Q, data=(R, dR))</span>
<span class="sd">    &gt;&gt;&gt; simulation = geometry.probe(T=linspace(0, 5, 51))</span>

<span class="sd">All instrument parameters can be specified when constructing the probe,</span>
<span class="sd">replacing the defaults that are associated with the instrument.  For</span>
<span class="sd">example, to include sample broadening effects in the resolution:</span>

<span class="sd">    &gt;&gt;&gt; probe2 = geometry.probe(Q=Q, data=(R, dR), sample_broadening=0.1,</span>
<span class="sd">    ...    name=&quot;probe2&quot;)</span>

<span class="sd">For magnetic systems a polarized beam probe is needed::</span>

<span class="sd">    &gt;&gt;&gt; magnetic_probe = geometry.magnetic_probe(T=np.linspace(0, 5, 100))</span>

<span class="sd">The string representation of the geometry prints a multi-line</span>
<span class="sd">description of the default instrument configuration:</span>

<span class="sd">    &gt;&gt;&gt; print(geometry)</span>
<span class="sd">    == Instrument SP:2 ==</span>
<span class="sd">    radiation = neutron at 5.0042 Angstrom with 0.9% resolution</span>
<span class="sd">    slit distances = 2086 mm and 230 mm</span>
<span class="sd">    fixed region below 0.5 and above 90 degrees</span>
<span class="sd">    slit openings at Tlo are 0.2 mm</span>
<span class="sd">    sample width = 1e+10 mm</span>
<span class="sd">    sample broadening = 0 degrees</span>

<span class="sd">Predefined Instruments</span>
<span class="sd">======================</span>

<span class="sd">Specific instruments can be defined for each facility.  This saves the users</span>
<span class="sd">having to remember details of the instrument geometry.</span>

<span class="sd">For example, the above SP:2 instrument could be defined as follows:</span>

<span class="sd">    &gt;&gt;&gt; class SP2(Monochromatic):</span>
<span class="sd">    ...    instrument = &quot;SP:2&quot;</span>
<span class="sd">    ...    radiation = &quot;neutron&quot;</span>
<span class="sd">    ...    wavelength = 5.0042   # Angstroms</span>
<span class="sd">    ...    dLoL = 0.009          # FWHM</span>
<span class="sd">    ...    d_s1 = 230.0 + 1856.0 # mm</span>
<span class="sd">    ...    d_s2 = 230.0          # mm</span>
<span class="sd">    ...    def load(self, filename, **kw):</span>
<span class="sd">    ...        Q, R, dR = loadtxt(datafile).T</span>
<span class="sd">    ...        probe = self.probe(Q=Q, data=(R, dR), **kw)</span>
<span class="sd">    ...        return probe</span>

<span class="sd">This definition can then be used to define the measurement geometry.  We</span>
<span class="sd">have added a load method which knows about the facility file format (in</span>
<span class="sd">this case, three column ASCII data Q, R, dR) so that we can load a datafile</span>
<span class="sd">in a couple of lines of code:</span>

<span class="sd">    &gt;&gt;&gt; geometry = SP2(Tlo=0.5, slits_at_Tlo=0.2, slits_below=0.1)</span>
<span class="sd">    &gt;&gt;&gt; probe3 = geometry.load(datafile)</span>

<span class="sd">The defaults() method prints the static components of the geometry:</span>

<span class="sd">    &gt;&gt;&gt; print(SP2.defaults())</span>
<span class="sd">    == Instrument class SP:2 ==</span>
<span class="sd">    radiation = neutron at 5.0042 Angstrom with 0.9% resolution</span>
<span class="sd">    slit distances = 2086 mm and 230 mm</span>

<span class="sd">GUI Usage</span>
<span class="sd">=========</span>

<span class="sd">Graphical user interfaces follow different usage patterns from scripts.</span>
<span class="sd">Here the emphasis will be on selecting a data set to process, displaying</span>
<span class="sd">its default metadata and allowing the user to override it.</span>

<span class="sd">File loading should follow the pattern established in reflectometry</span>
<span class="sd">reduction, with an extension registry and a fallback scheme whereby</span>
<span class="sd">files can be checked in a predefined order.  If the file cannot be</span>
<span class="sd">loaded, then the next loader is tried.  This should be extended with</span>
<span class="sd">the concept of a magic signature such as those used by graphics and</span>
<span class="sd">sound file applications: read the first block and run it through</span>
<span class="sd">the signature check before trying to load it.  For unrecognized</span>
<span class="sd">extensions, all loaders can be tried.</span>

<span class="sd">The file loader should return an instrument instance with metadata</span>
<span class="sd">initialized from the file header.  This metadata can be displayed</span>
<span class="sd">to the user along with a plot of the data and the resolution.  When</span>
<span class="sd">metadata values are changed, the resolution can be recomputed and the</span>
<span class="sd">display updated.  When the data set is accepted, the final resolution</span>
<span class="sd">calculation can be performed.</span>
<span class="sd">&quot;&quot;&quot;</span>

<span class="kn">from</span> <span class="nn">__future__</span> <span class="kn">import</span> <span class="n">division</span><span class="p">,</span> <span class="n">print_function</span>

<span class="c1"># TODO: the resolution calculator should not be responsible for loading</span>
<span class="c1"># the data; maybe do it as a mixin?</span>

<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="c1"># from numpy import pi, inf, sqrt, log, degrees, radians, cos, sin, tan</span>

<span class="kn">from</span> <span class="nn">.resolution</span> <span class="kn">import</span> <span class="n">QL2T</span>
<span class="kn">from</span> <span class="nn">.resolution</span> <span class="kn">import</span> <span class="n">bins</span><span class="p">,</span> <span class="n">binwidths</span><span class="p">,</span> <span class="n">binedges</span>
<span class="kn">from</span> <span class="nn">.resolution</span> <span class="kn">import</span> <span class="n">slit_widths</span><span class="p">,</span> <span class="n">divergence</span>
<span class="kn">from</span> <span class="nn">.probe</span> <span class="kn">import</span> <span class="n">make_probe</span><span class="p">,</span> <span class="n">PolarizedNeutronProbe</span>
<span class="kn">from</span> <span class="nn">.reflectivity</span> <span class="kn">import</span> <span class="n">BASE_GUIDE_ANGLE</span>


<div class="viewcode-block" id="Monochromatic">
<a class="viewcode-back" href="../../refl1d.instrument.html#refl1d.instrument.Monochromatic">[docs]</a>
<span class="k">class</span> <span class="nc">Monochromatic</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Instrument representation for scanning reflectometers.</span>

<span class="sd">    :Parameters:</span>
<span class="sd">        *instrument* : string</span>
<span class="sd">            name of the instrument</span>
<span class="sd">        *radiation* : string | xray or neutron</span>
<span class="sd">            source radiation type</span>
<span class="sd">        *d_s1*, *d_s2* : float | mm</span>
<span class="sd">            distance from sample to pre-sample slits 1 and 2; post-sample</span>
<span class="sd">            slits are ignored</span>
<span class="sd">        *wavelength* : float | |Ang|</span>
<span class="sd">            wavelength of the instrument</span>
<span class="sd">        *dLoL* : float</span>
<span class="sd">            constant relative wavelength dispersion; wavelength range and</span>
<span class="sd">            dispersion together determine the bins</span>
<span class="sd">        *slits* : float OR (float, float) | mm</span>
<span class="sd">            fixed slits</span>
<span class="sd">        *slits_at_Tlo* : float OR (float, float) | mm</span>
<span class="sd">            slit 1 and slit 2 openings at Tlo; this can be a scalar if both</span>
<span class="sd">            slits are open by the same amount, otherwise it is a pair (s1, s2).</span>
<span class="sd">        *slits_at_Qlo* : float OR (float, float) | mm</span>
<span class="sd">            equivalent to slits_at_Tlo, for instruments that are controlled by</span>
<span class="sd">            Q rather than theta</span>
<span class="sd">        *Tlo*, *Thi* : float | |deg|</span>
<span class="sd">            range of opening slits, or inf if slits are fixed.</span>
<span class="sd">        *Qlo*, *Qhi* : float | |1/Ang|</span>
<span class="sd">            range of opening slits when instrument is controlled by Q.</span>
<span class="sd">        *slits_below*, *slits_above* : float OR (float, float) | mm</span>
<span class="sd">            slit 1 and slit 2 openings below Tlo and above Thi; again, these</span>
<span class="sd">            can be scalar if slit 1 and slit 2 are the same, otherwise they</span>
<span class="sd">            are each a pair (s1, s2).  Below and above default to the values of</span>
<span class="sd">            the slits at Tlo and Thi respectively.</span>
<span class="sd">        *sample_width* : float | mm</span>
<span class="sd">            width of sample; at low angle with tiny samples, stray neutrons</span>
<span class="sd">            miss the sample and are not reflected onto the detector, so the</span>
<span class="sd">            sample itself acts as a slit, therefore the width of the sample</span>
<span class="sd">            may be needed to compute the resolution correctly</span>
<span class="sd">        *sample_broadening* : float | |deg| FWHM</span>
<span class="sd">            amount of angular divergence (+) or focusing (-) introduced by</span>
<span class="sd">            the sample; this is caused by sample warp, and may be read off</span>
<span class="sd">            of the rocking curve by subtracting (s1+s2)/2/(d_s1-d_s2) from</span>
<span class="sd">            the FWHM width of the rocking curve</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">instrument</span> <span class="o">=</span> <span class="s2">&quot;monochromatic&quot;</span>
    <span class="n">radiation</span> <span class="o">=</span> <span class="s2">&quot;unknown&quot;</span>
    <span class="c1"># Required attributes</span>
    <span class="n">wavelength</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="n">dLoL</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="n">d_s1</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="n">d_s2</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="c1"># Optional attributes</span>
    <span class="n">Tlo</span> <span class="o">=</span> <span class="mi">90</span>  <span class="c1"># Use 90 for fixed slits; this is effectively inf</span>
    <span class="n">Thi</span> <span class="o">=</span> <span class="mi">90</span>
    <span class="n">fixed_slits</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="n">slits_at_Tlo</span> <span class="o">=</span> <span class="kc">None</span>  <span class="c1"># Slit openings at Tlo, and default for slits_below</span>
    <span class="n">slits_below</span> <span class="o">=</span> <span class="kc">None</span>  <span class="c1"># Slit openings below Tlo, or fixed slits if Tlo=90</span>
    <span class="n">slits_above</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="n">sample_width</span> <span class="o">=</span> <span class="mf">1e10</span>  <span class="c1"># Large but finite value</span>
    <span class="n">sample_broadening</span> <span class="o">=</span> <span class="mi">0</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">**</span><span class="n">kw</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_translate_Q_to_theta</span><span class="p">(</span><span class="n">kw</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">kw</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">k</span><span class="p">):</span>
                <span class="nb">setattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;unexpected keyword argument &#39;</span><span class="si">%s</span><span class="s2">&#39;&quot;</span> <span class="o">%</span> <span class="n">k</span><span class="p">)</span>

<div class="viewcode-block" id="Monochromatic.probe">
<a class="viewcode-back" href="../../refl1d.instrument.html#refl1d.instrument.Monochromatic.probe">[docs]</a>
    <span class="k">def</span> <span class="nf">probe</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">**</span><span class="n">kw</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return a probe for use in simulation.</span>

<span class="sd">        :Parameters:</span>
<span class="sd">            *Q* : [float] | |Ang|</span>
<span class="sd">                Q values to be measured.</span>
<span class="sd">            *T* : [float] | |deg|</span>
<span class="sd">                Angles to be measured.</span>

<span class="sd">        Additional keyword parameters</span>

<span class="sd">        :Returns:</span>
<span class="sd">            *probe* : Probe</span>
<span class="sd">                Measurement probe with complete resolution information.  The</span>
<span class="sd">                probe will not have any data.</span>

<span class="sd">        If both *Q* and *T* are specified then *Q* takes precedents.</span>

<span class="sd">        You can override instrument parameters using key=value.  In</span>
<span class="sd">        particular, settings for *slits_at_Tlo*, *Tlo*, *Thi*,</span>
<span class="sd">        *slits_below*, and *slits_above* are used to define the</span>
<span class="sd">        angular divergence.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_translate_Q_to_theta</span><span class="p">(</span><span class="n">kw</span><span class="p">)</span>
        <span class="n">T</span><span class="p">,</span> <span class="n">dT</span><span class="p">,</span> <span class="n">L</span><span class="p">,</span> <span class="n">dL</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">resolution</span><span class="p">(</span><span class="o">**</span><span class="n">kw</span><span class="p">)</span>
        <span class="n">sample_broadening</span> <span class="o">=</span> <span class="n">kw</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;sample_broadening&quot;</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">sample_broadening</span><span class="p">)</span>
        <span class="n">kw</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">T</span><span class="o">=</span><span class="n">T</span><span class="p">,</span> <span class="n">dT</span><span class="o">=</span><span class="n">dT</span> <span class="o">-</span> <span class="n">sample_broadening</span><span class="p">,</span> <span class="n">L</span><span class="o">=</span><span class="n">L</span><span class="p">,</span> <span class="n">dL</span><span class="o">=</span><span class="n">dL</span><span class="p">)</span>
        <span class="n">kw</span><span class="o">.</span><span class="n">setdefault</span><span class="p">(</span><span class="s2">&quot;radiation&quot;</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">radiation</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">make_probe</span><span class="p">(</span><span class="o">**</span><span class="n">kw</span><span class="p">)</span></div>


<div class="viewcode-block" id="Monochromatic.magnetic_probe">
<a class="viewcode-back" href="../../refl1d.instrument.html#refl1d.instrument.Monochromatic.magnetic_probe">[docs]</a>
    <span class="k">def</span> <span class="nf">magnetic_probe</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">Aguide</span><span class="o">=</span><span class="n">BASE_GUIDE_ANGLE</span><span class="p">,</span> <span class="n">shared_beam</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">H</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="o">**</span><span class="n">kw</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Simulate a polarized measurement probe.</span>

<span class="sd">        Returns a probe with Q, angle, wavelength and the associated</span>
<span class="sd">        uncertainties, but not any data.</span>

<span class="sd">        Guide field angle *Aguide* can be specified, as well as keyword</span>
<span class="sd">        arguments for the geometry of the probe cross sections such as</span>
<span class="sd">        *slits_at_Tlo*, *Tlo*, *Thi*, *slits_below*, and *slits_above*</span>
<span class="sd">        to define the angular divergence.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">base_name</span> <span class="o">=</span> <span class="n">kw</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s2">&quot;name&quot;</span><span class="p">,</span> <span class="s2">&quot;&quot;</span><span class="p">)</span>
        <span class="n">probes</span> <span class="o">=</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">probe</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="n">base_name</span> <span class="o">+</span> <span class="n">xs</span><span class="p">,</span> <span class="o">**</span><span class="n">kw</span><span class="p">)</span> <span class="k">for</span> <span class="n">xs</span> <span class="ow">in</span> <span class="p">(</span><span class="s2">&quot;--&quot;</span><span class="p">,</span> <span class="s2">&quot;-+&quot;</span><span class="p">,</span> <span class="s2">&quot;+-&quot;</span><span class="p">,</span> <span class="s2">&quot;++&quot;</span><span class="p">)]</span>
        <span class="n">probe</span> <span class="o">=</span> <span class="n">PolarizedNeutronProbe</span><span class="p">(</span><span class="n">probes</span><span class="p">,</span> <span class="n">Aguide</span><span class="o">=</span><span class="n">Aguide</span><span class="p">,</span> <span class="n">H</span><span class="o">=</span><span class="n">H</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">shared_beam</span><span class="p">:</span>
            <span class="n">probe</span><span class="o">.</span><span class="n">shared_beam</span><span class="p">()</span>  <span class="c1"># Share the beam parameters by default</span>
        <span class="k">return</span> <span class="n">probe</span></div>


<div class="viewcode-block" id="Monochromatic.resolution">
<a class="viewcode-back" href="../../refl1d.instrument.html#refl1d.instrument.Monochromatic.resolution">[docs]</a>
    <span class="k">def</span> <span class="nf">resolution</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">**</span><span class="n">kw</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Calculate resolution at each angle.</span>

<span class="sd">        :Return:</span>
<span class="sd">            *T*, *dT* : [float] | |deg|</span>
<span class="sd">                Angles and angular divergence.</span>
<span class="sd">            *L*, *dL* : [float] | |Ang|</span>
<span class="sd">                Wavelengths and wavelength dispersion.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_translate_Q_to_theta</span><span class="p">(</span><span class="n">kw</span><span class="p">)</span>
        <span class="k">if</span> <span class="s2">&quot;T&quot;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">kw</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;resolution requires slits and either T or Q&quot;</span><span class="p">)</span>

        <span class="n">L</span> <span class="o">=</span> <span class="n">kw</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;L&quot;</span><span class="p">,</span> <span class="n">kw</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;wavelength&quot;</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">wavelength</span><span class="p">))</span>
        <span class="k">if</span> <span class="s2">&quot;dL&quot;</span> <span class="ow">in</span> <span class="n">kw</span><span class="p">:</span>
            <span class="n">dL</span> <span class="o">=</span> <span class="n">kw</span><span class="p">[</span><span class="s2">&quot;dL&quot;</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">dL</span> <span class="o">=</span> <span class="n">kw</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;dLoL&quot;</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">dLoL</span><span class="p">)</span> <span class="o">*</span> <span class="n">L</span>

        <span class="k">if</span> <span class="n">L</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">or</span> <span class="n">dL</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;Need wavelength and wavelength dispersion to compute resolution&quot;</span><span class="p">)</span>

        <span class="n">T</span> <span class="o">=</span> <span class="n">kw</span><span class="p">[</span><span class="s2">&quot;T&quot;</span><span class="p">]</span>
        <span class="k">if</span> <span class="s2">&quot;dT&quot;</span> <span class="ow">in</span> <span class="n">kw</span><span class="p">:</span>
            <span class="n">dT</span> <span class="o">=</span> <span class="n">kw</span><span class="p">[</span><span class="s2">&quot;dT&quot;</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">if</span> <span class="s2">&quot;slits&quot;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">kw</span><span class="p">:</span>
                <span class="n">kw</span><span class="p">[</span><span class="s2">&quot;slits&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">calc_slits</span><span class="p">(</span><span class="o">**</span><span class="n">kw</span><span class="p">)</span>
            <span class="n">dT</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">calc_dT</span><span class="p">(</span><span class="o">**</span><span class="n">kw</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">T</span><span class="p">,</span> <span class="n">dT</span><span class="p">,</span> <span class="n">L</span><span class="p">,</span> <span class="n">dL</span></div>


<div class="viewcode-block" id="Monochromatic.calc_slits">
<a class="viewcode-back" href="../../refl1d.instrument.html#refl1d.instrument.Monochromatic.calc_slits">[docs]</a>
    <span class="k">def</span> <span class="nf">calc_slits</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">**</span><span class="n">kw</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Determines slit openings from measurement pattern.</span>

<span class="sd">        If slits are fixed simply return the same slits for every angle,</span>
<span class="sd">        otherwise use an opening range [Tlo, Thi] and the value of the</span>
<span class="sd">        slits at the start of the opening to define the slits.  Slits</span>
<span class="sd">        below Tlo and above Thi can be specified separately.</span>

<span class="sd">        *T* OR *Q*       incident angle or Q</span>
<span class="sd">        *Tlo*, *Thi*     angle range over which slits are opening</span>
<span class="sd">        *slits_at_Tlo*   openings at the start of the range, or fixed opening</span>
<span class="sd">        *slits_below*, *slits_above*   openings below and above the range</span>

<span class="sd">        Use fixed_slits is available, otherwise use opening slits.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_translate_Q_to_theta</span><span class="p">(</span><span class="n">kw</span><span class="p">)</span>
        <span class="k">if</span> <span class="s2">&quot;T&quot;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">kw</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;calc_slits requires angle T=... or Q=...&quot;</span><span class="p">)</span>
        <span class="n">T</span> <span class="o">=</span> <span class="n">kw</span><span class="p">[</span><span class="s2">&quot;T&quot;</span><span class="p">]</span>
        <span class="n">Tlo</span> <span class="o">=</span> <span class="n">kw</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;Tlo&quot;</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">Tlo</span><span class="p">)</span>
        <span class="n">Thi</span> <span class="o">=</span> <span class="n">kw</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;Thi&quot;</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">Thi</span><span class="p">)</span>
        <span class="n">fixed_slits</span> <span class="o">=</span> <span class="n">kw</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;fixed_slits&quot;</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">fixed_slits</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">fixed_slits</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">slits_at_Tlo</span> <span class="o">=</span> <span class="n">slits_below</span> <span class="o">=</span> <span class="n">slits_above</span> <span class="o">=</span> <span class="n">fixed_slits</span>
            <span class="n">Tlo</span> <span class="o">=</span> <span class="mi">90</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">slits_at_Tlo</span> <span class="o">=</span> <span class="n">kw</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;slits_at_Tlo&quot;</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">slits_at_Tlo</span><span class="p">)</span>
            <span class="n">slits_below</span> <span class="o">=</span> <span class="n">kw</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;slits_below&quot;</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">slits_below</span><span class="p">)</span>
            <span class="n">slits_above</span> <span class="o">=</span> <span class="n">kw</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;slits_above&quot;</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">slits_above</span><span class="p">)</span>

        <span class="c1"># Otherwise we are using opening slits</span>
        <span class="k">if</span> <span class="n">Tlo</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">or</span> <span class="n">slits_at_Tlo</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;Resolution calculation requires Tlo and slits_at_Tlo&quot;</span><span class="p">)</span>
        <span class="n">slits</span> <span class="o">=</span> <span class="n">slit_widths</span><span class="p">(</span>
            <span class="n">T</span><span class="o">=</span><span class="n">T</span><span class="p">,</span> <span class="n">slits_at_Tlo</span><span class="o">=</span><span class="n">slits_at_Tlo</span><span class="p">,</span> <span class="n">Tlo</span><span class="o">=</span><span class="n">Tlo</span><span class="p">,</span> <span class="n">Thi</span><span class="o">=</span><span class="n">Thi</span><span class="p">,</span> <span class="n">slits_below</span><span class="o">=</span><span class="n">slits_below</span><span class="p">,</span> <span class="n">slits_above</span><span class="o">=</span><span class="n">slits_above</span>
        <span class="p">)</span>
        <span class="k">return</span> <span class="n">slits</span></div>


<div class="viewcode-block" id="Monochromatic.calc_dT">
<a class="viewcode-back" href="../../refl1d.instrument.html#refl1d.instrument.Monochromatic.calc_dT">[docs]</a>
    <span class="k">def</span> <span class="nf">calc_dT</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">**</span><span class="n">kw</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Compute the angular divergence for given slits and angles</span>

<span class="sd">        :Parameters:</span>
<span class="sd">            *T* OR *Q* : [float] | |deg| OR |1/Ang|</span>
<span class="sd">                measurement angles</span>
<span class="sd">            *slits* : float OR (float, float) | mm</span>
<span class="sd">                total slit opening from edge to edge, not beam center to edge</span>
<span class="sd">            *d_s1*, *d_s2* : float | mm</span>
<span class="sd">                distance from sample to slit 1 and slit 2</span>
<span class="sd">            *sample_width* : float | mm</span>
<span class="sd">                size of sample</span>
<span class="sd">            *sample_broadening* : float | |deg| FWHM</span>
<span class="sd">                resolution changes from sample warp</span>

<span class="sd">        :Returns:</span>
<span class="sd">            *dT* : [float] | |deg| FWHM</span>
<span class="sd">                angular divergence</span>

<span class="sd">        *sample_broadening* can be estimated from W, the full width at half</span>
<span class="sd">        maximum of a rocking curve measured in degrees:</span>

<span class="sd">            sample_broadening = W - degrees( 0.5*(s1+s2) / (d1-d2))</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_translate_Q_to_theta</span><span class="p">(</span><span class="n">kw</span><span class="p">)</span>
        <span class="k">if</span> <span class="s2">&quot;T&quot;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">kw</span> <span class="ow">or</span> <span class="s2">&quot;slits&quot;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">kw</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;calc_dT requires slits and either T or Q&quot;</span><span class="p">)</span>
        <span class="n">slits</span> <span class="o">=</span> <span class="n">kw</span><span class="p">[</span><span class="s2">&quot;slits&quot;</span><span class="p">]</span>
        <span class="n">T</span> <span class="o">=</span> <span class="n">kw</span><span class="p">[</span><span class="s2">&quot;T&quot;</span><span class="p">]</span>
        <span class="n">d_s1</span> <span class="o">=</span> <span class="n">kw</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;d_s1&quot;</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">d_s1</span><span class="p">)</span>
        <span class="n">d_s2</span> <span class="o">=</span> <span class="n">kw</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;d_s2&quot;</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">d_s2</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">d_s1</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">or</span> <span class="n">d_s2</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;Need slit distances d_s1, d_s2 to compute resolution&quot;</span><span class="p">)</span>
        <span class="n">sample_width</span> <span class="o">=</span> <span class="n">kw</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;sample_width&quot;</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">sample_width</span><span class="p">)</span>
        <span class="n">sample_broadening</span> <span class="o">=</span> <span class="n">kw</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;sample_broadening&quot;</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">sample_broadening</span><span class="p">)</span>
        <span class="n">dT</span> <span class="o">=</span> <span class="n">divergence</span><span class="p">(</span>
            <span class="n">T</span><span class="o">=</span><span class="n">T</span><span class="p">,</span> <span class="n">slits</span><span class="o">=</span><span class="n">slits</span><span class="p">,</span> <span class="n">distance</span><span class="o">=</span><span class="p">(</span><span class="n">d_s1</span><span class="p">,</span> <span class="n">d_s2</span><span class="p">),</span> <span class="n">sample_width</span><span class="o">=</span><span class="n">sample_width</span><span class="p">,</span> <span class="n">sample_broadening</span><span class="o">=</span><span class="n">sample_broadening</span>
        <span class="p">)</span>

        <span class="k">return</span> <span class="n">dT</span></div>


    <span class="k">def</span> <span class="nf">_translate_Q_to_theta</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">kw</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Rewrite keyword arguments with Q values translated to theta values.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Grab wavelength first so we can translate Qlo/Qhi to Tlo/Thi no</span>
        <span class="c1"># matter what order the keywords appear.</span>
        <span class="n">wavelength</span> <span class="o">=</span> <span class="n">kw</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;wavelength&quot;</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">wavelength</span><span class="p">)</span>
        <span class="k">if</span> <span class="s2">&quot;Q&quot;</span> <span class="ow">in</span> <span class="n">kw</span><span class="p">:</span>
            <span class="n">kw</span><span class="p">[</span><span class="s2">&quot;T&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">QL2T</span><span class="p">(</span><span class="n">kw</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s2">&quot;Q&quot;</span><span class="p">),</span> <span class="n">wavelength</span><span class="p">)</span>
        <span class="k">if</span> <span class="s2">&quot;Qlo&quot;</span> <span class="ow">in</span> <span class="n">kw</span><span class="p">:</span>
            <span class="n">kw</span><span class="p">[</span><span class="s2">&quot;Tlo&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">QL2T</span><span class="p">(</span><span class="n">kw</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s2">&quot;Qlo&quot;</span><span class="p">),</span> <span class="n">wavelength</span><span class="p">)</span>
        <span class="k">if</span> <span class="s2">&quot;Qhi&quot;</span> <span class="ow">in</span> <span class="n">kw</span><span class="p">:</span>
            <span class="n">kw</span><span class="p">[</span><span class="s2">&quot;Thi&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">QL2T</span><span class="p">(</span><span class="n">kw</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s2">&quot;Qhi&quot;</span><span class="p">),</span> <span class="n">wavelength</span><span class="p">)</span>
        <span class="k">if</span> <span class="s2">&quot;slits_at_Qlo&quot;</span> <span class="ow">in</span> <span class="n">kw</span><span class="p">:</span>
            <span class="n">kw</span><span class="p">[</span><span class="s2">&quot;slits_at_Tlo&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">kw</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s2">&quot;slits_at_Qlo&quot;</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__str__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">msg</span> <span class="o">=</span> <span class="s2">&quot;&quot;&quot;</span><span class="se">\</span>
<span class="s2">== Instrument </span><span class="si">%(name)s</span><span class="s2"> ==</span>
<span class="s2">radiation = </span><span class="si">%(radiation)s</span><span class="s2"> at </span><span class="si">%(L)g</span><span class="s2"> Angstrom with </span><span class="si">%(dLpercent)g%%</span><span class="s2"> resolution</span>
<span class="s2">slit distances = </span><span class="si">%(d_s1)g</span><span class="s2"> mm and </span><span class="si">%(d_s2)g</span><span class="s2"> mm</span>
<span class="s2">fixed region below </span><span class="si">%(Tlo)g</span><span class="s2"> and above </span><span class="si">%(Thi)g</span><span class="s2"> degrees</span>
<span class="s2">slit openings at Tlo are </span><span class="si">%(slits_at_Tlo)s</span><span class="s2"> mm</span>
<span class="s2">sample width = </span><span class="si">%(sample_width)g</span><span class="s2"> mm</span>
<span class="s2">sample broadening = </span><span class="si">%(sample_broadening)g</span><span class="s2"> degrees</span><span class="se">\</span>
<span class="s2">&quot;&quot;&quot;</span> <span class="o">%</span> <span class="nb">dict</span><span class="p">(</span>
            <span class="n">name</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">instrument</span><span class="p">,</span>
            <span class="n">L</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">wavelength</span><span class="p">,</span>
            <span class="n">dLpercent</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">dLoL</span> <span class="o">*</span> <span class="mi">100</span><span class="p">,</span>
            <span class="n">d_s1</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">d_s1</span><span class="p">,</span>
            <span class="n">d_s2</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">d_s2</span><span class="p">,</span>
            <span class="n">sample_width</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">sample_width</span><span class="p">,</span>
            <span class="n">sample_broadening</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">sample_broadening</span><span class="p">,</span>
            <span class="n">Tlo</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">Tlo</span><span class="p">,</span>
            <span class="n">Thi</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">Thi</span><span class="p">,</span>
            <span class="n">slits_at_Tlo</span><span class="o">=</span><span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">slits_at_Tlo</span><span class="p">),</span>
            <span class="n">radiation</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">radiation</span><span class="p">,</span>
        <span class="p">)</span>
        <span class="k">return</span> <span class="n">msg</span>

<div class="viewcode-block" id="Monochromatic.defaults">
<a class="viewcode-back" href="../../refl1d.instrument.html#refl1d.instrument.Monochromatic.defaults">[docs]</a>
    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">defaults</span><span class="p">(</span><span class="bp">cls</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return default instrument properties as a printable string.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">msg</span> <span class="o">=</span> <span class="s2">&quot;&quot;&quot;</span><span class="se">\</span>
<span class="s2">== Instrument class </span><span class="si">%(name)s</span><span class="s2"> ==</span>
<span class="s2">radiation = </span><span class="si">%(radiation)s</span><span class="s2"> at </span><span class="si">%(L)s</span><span class="s2"> Angstrom with </span><span class="si">%(dL)s</span><span class="s2"> resolution</span>
<span class="s2">slit distances = </span><span class="si">%(d_s1)s</span><span class="s2"> mm and </span><span class="si">%(d_s2)s</span><span class="s2"> mm&quot;&quot;&quot;</span>
        <span class="n">L</span><span class="p">,</span> <span class="n">d_s1</span><span class="p">,</span> <span class="n">d_s2</span> <span class="o">=</span> <span class="p">[</span><span class="s2">&quot;</span><span class="si">%g</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="n">v</span> <span class="k">if</span> <span class="n">v</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="k">else</span> <span class="s2">&quot;unknown&quot;</span> <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="p">(</span><span class="bp">cls</span><span class="o">.</span><span class="n">wavelength</span><span class="p">,</span> <span class="bp">cls</span><span class="o">.</span><span class="n">d_s1</span><span class="p">,</span> <span class="bp">cls</span><span class="o">.</span><span class="n">d_s2</span><span class="p">)]</span>
        <span class="n">dL</span> <span class="o">=</span> <span class="s2">&quot;</span><span class="si">%g%%</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="bp">cls</span><span class="o">.</span><span class="n">dLoL</span> <span class="o">*</span> <span class="mi">100</span><span class="p">)</span> <span class="k">if</span> <span class="bp">cls</span><span class="o">.</span><span class="n">dLoL</span> <span class="k">else</span> <span class="s2">&quot;unknown&quot;</span>
        <span class="k">return</span> <span class="n">msg</span> <span class="o">%</span> <span class="nb">dict</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="bp">cls</span><span class="o">.</span><span class="n">instrument</span><span class="p">,</span> <span class="n">radiation</span><span class="o">=</span><span class="bp">cls</span><span class="o">.</span><span class="n">radiation</span><span class="p">,</span> <span class="n">L</span><span class="o">=</span><span class="n">L</span><span class="p">,</span> <span class="n">dL</span><span class="o">=</span><span class="n">dL</span><span class="p">,</span> <span class="n">d_s1</span><span class="o">=</span><span class="n">d_s1</span><span class="p">,</span> <span class="n">d_s2</span><span class="o">=</span><span class="n">d_s2</span><span class="p">)</span></div>
</div>



<div class="viewcode-block" id="Pulsed">
<a class="viewcode-back" href="../../refl1d.instrument.html#refl1d.instrument.Pulsed">[docs]</a>
<span class="k">class</span> <span class="nc">Pulsed</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Instrument representation for pulsed reflectometers.</span>

<span class="sd">    :Parameters:</span>
<span class="sd">        *instrument* : string</span>
<span class="sd">            name of the instrument</span>
<span class="sd">        *radiation* : string | xray, neutron</span>
<span class="sd">            source radiation type</span>
<span class="sd">        *TOF_range* : (float, float)</span>
<span class="sd">            usabe range of times for TOF data</span>
<span class="sd">        *T* : float | |deg|</span>
<span class="sd">            sample angle</span>
<span class="sd">        *d_s1*, *d_s2* : float | mm</span>
<span class="sd">            distance from sample to pre-sample slits 1 and 2; post-sample</span>
<span class="sd">            slits are ignored</span>
<span class="sd">        *wavelength* : (float, float) | |Ang|</span>
<span class="sd">            wavelength range for the measurement</span>
<span class="sd">        *dLoL* : float</span>
<span class="sd">            constant relative wavelength dispersion; wavelength range and</span>
<span class="sd">            dispersion together determine the bins</span>
<span class="sd">        *slits* : float OR (float, float) | mm</span>
<span class="sd">            fixed slits</span>
<span class="sd">        *slits_at_Tlo* : float OR (float, float) | mm</span>
<span class="sd">            slit 1 and slit 2 openings at Tlo; this can be a scalar if both</span>
<span class="sd">            slits are open by the same amount, otherwise it is a pair (s1, s2).</span>
<span class="sd">        *Tlo*, *Thi* : float | |deg|</span>
<span class="sd">            range of opening slits, or inf if slits are fixed.</span>
<span class="sd">        *slits_below*, *slits_above* : float OR (float, float) | mm</span>
<span class="sd">            slit 1 and slit 2 openings below Tlo and above Thi; again, these</span>
<span class="sd">            can be scalar if slit 1 and slit 2 are the same, otherwise they</span>
<span class="sd">            are each a pair (s1, s2).  Below and above default to the values of</span>
<span class="sd">            the slits at Tlo and Thi respectively.</span>
<span class="sd">        *sample_width* : float | mm</span>
<span class="sd">            width of sample; at low angle with tiny samples, stray neutrons</span>
<span class="sd">            miss the sample and are not reflected onto the detector, so the</span>
<span class="sd">            sample itself acts as a slit, therefore the width of the sample</span>
<span class="sd">            may be needed to compute the resolution correctly</span>
<span class="sd">        *sample_broadening* : float | |deg| FWHM</span>
<span class="sd">            amount of angular divergence (+) or focusing (-) introduced by</span>
<span class="sd">            the sample; this is caused by sample warp, and may be read off</span>
<span class="sd">            of the rocking curve by subtracting 0.5*(s1+s2)/(d_s1-d_s2) from</span>
<span class="sd">            the FWHM width of the rocking curve</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">instrument</span> <span class="o">=</span> <span class="s2">&quot;pulsed&quot;</span>
    <span class="n">radiation</span> <span class="o">=</span> <span class="s2">&quot;neutron&quot;</span>  <span class="c1"># unless someone knows how to do TOF Xray...</span>
    <span class="c1"># Required attributes</span>
    <span class="n">d_s1</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="n">d_s2</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="n">slits</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="n">T</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="n">wavelength</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="n">dLoL</span> <span class="o">=</span> <span class="kc">None</span>  <span class="c1"># usually 0.02 for 2% FWHM</span>
    <span class="c1"># Optional attributes</span>
    <span class="n">TOF_range</span> <span class="o">=</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">inf</span><span class="p">)</span>
    <span class="n">Tlo</span> <span class="o">=</span> <span class="mi">90</span>  <span class="c1"># Use 90 for fixed slits; this is effectively inf</span>
    <span class="n">Thi</span> <span class="o">=</span> <span class="mi">90</span>
    <span class="n">fixed_slits</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="n">slits_at_Tlo</span> <span class="o">=</span> <span class="kc">None</span>  <span class="c1"># Slit openings at Tlo, and default for slits_below</span>
    <span class="n">slits_below</span> <span class="o">=</span> <span class="kc">None</span>  <span class="c1"># Slit openings below Tlo, or fixed slits if Tlo=90</span>
    <span class="n">slits_above</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="n">sample_width</span> <span class="o">=</span> <span class="mf">1e10</span>  <span class="c1"># Large but finite value</span>
    <span class="n">sample_broadening</span> <span class="o">=</span> <span class="mi">0</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">**</span><span class="n">kw</span><span class="p">):</span>
        <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">kw</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">k</span><span class="p">):</span>
                <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;unexpected keyword argument &#39;</span><span class="si">%s</span><span class="s2">&#39;&quot;</span> <span class="o">%</span> <span class="n">k</span><span class="p">)</span>
            <span class="nb">setattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span><span class="p">)</span>

<div class="viewcode-block" id="Pulsed.probe">
<a class="viewcode-back" href="../../refl1d.instrument.html#refl1d.instrument.Pulsed.probe">[docs]</a>
    <span class="k">def</span> <span class="nf">probe</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">**</span><span class="n">kw</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Simulate a measurement probe.</span>

<span class="sd">        Returns a probe with Q, angle, wavelength and the associated</span>
<span class="sd">        uncertainties, but not any data.</span>

<span class="sd">        You can override instrument parameters using key=value.</span>
<span class="sd">        In particular, slit settings *slits* and *T* define</span>
<span class="sd">        the angular divergence and *dLoL* defines the wavelength</span>
<span class="sd">        resolution.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">low</span><span class="p">,</span> <span class="n">high</span> <span class="o">=</span> <span class="n">kw</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;wavelength&quot;</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">wavelength</span><span class="p">)</span>
        <span class="n">dLoL</span> <span class="o">=</span> <span class="n">kw</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;dLoL&quot;</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">dLoL</span><span class="p">)</span>
        <span class="n">T</span> <span class="o">=</span> <span class="n">kw</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s2">&quot;T&quot;</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">T</span><span class="p">)</span>
        <span class="n">L</span> <span class="o">=</span> <span class="n">bins</span><span class="p">(</span><span class="n">low</span><span class="p">,</span> <span class="n">high</span><span class="p">,</span> <span class="n">dLoL</span><span class="p">)</span>
        <span class="n">dL</span> <span class="o">=</span> <span class="n">binwidths</span><span class="p">(</span><span class="n">L</span><span class="p">)</span>
        <span class="n">T</span><span class="p">,</span> <span class="n">dT</span><span class="p">,</span> <span class="n">L</span><span class="p">,</span> <span class="n">dL</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">resolution</span><span class="p">(</span><span class="n">L</span><span class="o">=</span><span class="n">L</span><span class="p">,</span> <span class="n">dL</span><span class="o">=</span><span class="n">dL</span><span class="p">,</span> <span class="n">T</span><span class="o">=</span><span class="n">T</span><span class="p">,</span> <span class="o">**</span><span class="n">kw</span><span class="p">)</span>
        <span class="n">sample_broadening</span> <span class="o">=</span> <span class="n">kw</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;sample_broadening&quot;</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">sample_broadening</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">make_probe</span><span class="p">(</span><span class="n">T</span><span class="o">=</span><span class="n">T</span><span class="p">,</span> <span class="n">dT</span><span class="o">=</span><span class="n">dT</span> <span class="o">-</span> <span class="n">sample_broadening</span><span class="p">,</span> <span class="n">L</span><span class="o">=</span><span class="n">L</span><span class="p">,</span> <span class="n">dL</span><span class="o">=</span><span class="n">dL</span><span class="p">,</span> <span class="n">radiation</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">radiation</span><span class="p">,</span> <span class="o">**</span><span class="n">kw</span><span class="p">)</span></div>


<div class="viewcode-block" id="Pulsed.magnetic_probe">
<a class="viewcode-back" href="../../refl1d.instrument.html#refl1d.instrument.Pulsed.magnetic_probe">[docs]</a>
    <span class="k">def</span> <span class="nf">magnetic_probe</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">Aguide</span><span class="o">=</span><span class="n">BASE_GUIDE_ANGLE</span><span class="p">,</span> <span class="n">shared_beam</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="o">**</span><span class="n">kw</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Simulate a polarized measurement probe.</span>

<span class="sd">        Returns a probe with Q, angle, wavelength and the associated</span>
<span class="sd">        uncertainties, but not any data.</span>

<span class="sd">        Guide field angle *Aguide* can be specified, as well as keyword</span>
<span class="sd">        arguments for the geometry of the probe cross sections such as</span>
<span class="sd">        slit settings *slits* and *T* to define the angular divergence</span>
<span class="sd">        and *dLoL* to define the wavelength resolution.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">probes</span> <span class="o">=</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">probe</span><span class="p">(</span><span class="o">**</span><span class="n">kw</span><span class="p">)</span> <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">4</span><span class="p">)]</span>
        <span class="n">probe</span> <span class="o">=</span> <span class="n">PolarizedNeutronProbe</span><span class="p">(</span><span class="n">probes</span><span class="p">,</span> <span class="n">Aguide</span><span class="o">=</span><span class="n">Aguide</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">shared_beam</span><span class="p">:</span>
            <span class="n">probe</span><span class="o">.</span><span class="n">shared_beam</span><span class="p">()</span>  <span class="c1"># Share the beam parameters by default</span>
        <span class="k">return</span> <span class="n">probe</span></div>


<div class="viewcode-block" id="Pulsed.simulate">
<a class="viewcode-back" href="../../refl1d.instrument.html#refl1d.instrument.Pulsed.simulate">[docs]</a>
    <span class="k">def</span> <span class="nf">simulate</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">sample</span><span class="p">,</span> <span class="n">uncertainty</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="o">**</span><span class="n">kw</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Simulate a run with a particular sample.</span>

<span class="sd">        :Parameters:</span>
<span class="sd">            *sample* : Stack</span>
<span class="sd">                Reflectometry model</span>
<span class="sd">            *T* : [float] | |deg|</span>
<span class="sd">                List of angles to be measured, such as [0.15, 0.4, 1, 2].</span>
<span class="sd">            *slits* : [float] or [(float, float)] | mm</span>
<span class="sd">                Slit settings for each angle.</span>
<span class="sd">            *uncertainty* = 1 : float or [float] | %</span>
<span class="sd">                Incident intensity is set so that the median dR/R is equal</span>
<span class="sd">                to *uncertainty*, where R is the idealized reflectivity</span>
<span class="sd">                of the sample.</span>
<span class="sd">            *dLoL* = 0.02: float</span>
<span class="sd">                Wavelength resolution</span>
<span class="sd">            *normalize* = True : boolean</span>
<span class="sd">                Whether to normalize the intensities</span>
<span class="sd">            *theta_offset* = 0 : float | |deg|</span>
<span class="sd">                Sample alignment error</span>
<span class="sd">            *background* = 0 : float</span>
<span class="sd">                Background counts per incident neutron (background is</span>
<span class="sd">                assumed to be independent of measurement geometry).</span>
<span class="sd">            *back_reflectivity* = False : boolean</span>
<span class="sd">                Whether beam travels through incident medium</span>
<span class="sd">                or through substrate.</span>
<span class="sd">            *back_absorption* = 1 : float</span>
<span class="sd">                Absorption factor for beam traveling through substrate.</span>
<span class="sd">                Only needed for back reflectivity measurements.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="kn">from</span> <span class="nn">numpy.random</span> <span class="kn">import</span> <span class="n">poisson</span> <span class="k">as</span> <span class="n">pois</span>
        <span class="kn">from</span> <span class="nn">.rebin</span> <span class="kn">import</span> <span class="n">rebin</span>
        <span class="kn">from</span> <span class="nn">.experiment</span> <span class="kn">import</span> <span class="n">Experiment</span>
        <span class="kn">from</span> <span class="nn">.probe</span> <span class="kn">import</span> <span class="n">ProbeSet</span>

        <span class="n">T</span> <span class="o">=</span> <span class="n">kw</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s2">&quot;T&quot;</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">T</span><span class="p">)</span>
        <span class="n">slits</span> <span class="o">=</span> <span class="n">kw</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s2">&quot;slits&quot;</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">slits</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">slits</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;Need slit openings for simulation&quot;</span><span class="p">)</span>

        <span class="n">dLoL</span> <span class="o">=</span> <span class="n">kw</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s2">&quot;dLoL&quot;</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">dLoL</span><span class="p">)</span>
        <span class="n">normalize</span> <span class="o">=</span> <span class="n">kw</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s2">&quot;normalize&quot;</span><span class="p">,</span> <span class="kc">True</span><span class="p">)</span>
        <span class="n">theta_offset</span> <span class="o">=</span> <span class="n">kw</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s2">&quot;theta_offset&quot;</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
        <span class="n">background</span> <span class="o">=</span> <span class="n">kw</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s2">&quot;background&quot;</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
        <span class="n">back_reflectivity</span> <span class="o">=</span> <span class="n">kw</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s2">&quot;back_reflectivity&quot;</span><span class="p">,</span> <span class="kc">False</span><span class="p">)</span>
        <span class="n">back_absorption</span> <span class="o">=</span> <span class="n">kw</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s2">&quot;back_absorption&quot;</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
        <span class="n">uncertainty</span> <span class="o">*=</span> <span class="mf">0.01</span>

        <span class="c1"># Compute reflectivity with resolution and added noise</span>
        <span class="n">probes</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">Ti</span><span class="p">,</span> <span class="n">Si</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">T</span><span class="p">,</span> <span class="n">slits</span><span class="p">):</span>
            <span class="n">probe</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">probe</span><span class="p">(</span><span class="n">T</span><span class="o">=</span><span class="n">Ti</span><span class="p">,</span> <span class="n">slits</span><span class="o">=</span><span class="n">Si</span><span class="p">,</span> <span class="n">dLoL</span><span class="o">=</span><span class="n">dLoL</span><span class="p">)</span>
            <span class="n">probe</span><span class="o">.</span><span class="n">back_reflectivity</span> <span class="o">=</span> <span class="n">back_reflectivity</span>
            <span class="n">probe</span><span class="o">.</span><span class="n">theta_offset</span><span class="o">.</span><span class="n">value</span> <span class="o">=</span> <span class="n">theta_offset</span>
            <span class="n">probe</span><span class="o">.</span><span class="n">back_absorption</span><span class="o">.</span><span class="n">value</span> <span class="o">=</span> <span class="n">back_absorption</span>
            <span class="n">M</span> <span class="o">=</span> <span class="n">Experiment</span><span class="p">(</span><span class="n">probe</span><span class="o">=</span><span class="n">probe</span><span class="p">,</span> <span class="n">sample</span><span class="o">=</span><span class="n">sample</span><span class="p">)</span>
            <span class="n">_</span><span class="p">,</span> <span class="n">Rth</span> <span class="o">=</span> <span class="n">M</span><span class="o">.</span><span class="n">reflectivity</span><span class="p">()</span>
            <span class="c1"># Note: probe.L is reversed because L is sorted by increasing</span>
            <span class="c1"># Q in probe.</span>
            <span class="n">I</span> <span class="o">=</span> <span class="n">rebin</span><span class="p">(</span><span class="n">binedges</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">feather</span><span class="p">[</span><span class="mi">0</span><span class="p">]),</span> <span class="bp">self</span><span class="o">.</span><span class="n">feather</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">binedges</span><span class="p">(</span><span class="n">probe</span><span class="o">.</span><span class="n">L</span><span class="p">[::</span><span class="o">-</span><span class="mi">1</span><span class="p">]))[::</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
            <span class="n">Ci</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">median</span><span class="p">(</span><span class="mf">1.0</span> <span class="o">/</span> <span class="p">(</span><span class="n">uncertainty</span><span class="o">**</span><span class="mi">2</span> <span class="o">*</span> <span class="n">I</span> <span class="o">*</span> <span class="n">Rth</span><span class="p">))</span>
            <span class="n">Igoal</span> <span class="o">=</span> <span class="n">Ci</span> <span class="o">*</span> <span class="n">I</span>
            <span class="n">Ibeam</span> <span class="o">=</span> <span class="n">pois</span><span class="p">(</span><span class="n">Igoal</span><span class="p">)</span> <span class="o">+</span> <span class="mf">1.0</span>

            <span class="n">Irefl</span> <span class="o">=</span> <span class="n">pois</span><span class="p">(</span><span class="n">Igoal</span> <span class="o">*</span> <span class="n">Rth</span><span class="p">)</span> <span class="o">+</span> <span class="mf">1.0</span>
            <span class="k">if</span> <span class="n">background</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">Irefl</span> <span class="o">+=</span> <span class="n">pois</span><span class="p">(</span><span class="n">Igoal</span> <span class="o">*</span> <span class="n">background</span><span class="p">)</span> <span class="o">+</span> <span class="mf">1.0</span>
                <span class="n">Iback</span> <span class="o">=</span> <span class="n">pois</span><span class="p">(</span><span class="n">Igoal</span> <span class="o">*</span> <span class="n">background</span><span class="p">)</span> <span class="o">+</span> <span class="mf">1.0</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">Iback</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="c1"># Set intensity/background _after_ calculating the theory function</span>
            <span class="c1"># since we don&#39;t want the theory function altered by them.</span>
            <span class="n">probe</span><span class="o">.</span><span class="n">background</span><span class="o">.</span><span class="n">value</span> <span class="o">=</span> <span class="n">background</span>
            <span class="c1"># Correct for the feather.  This has to be done otherwise we</span>
            <span class="c1"># won&#39;t see the correct reflectivity.  Even if corrected for</span>
            <span class="c1"># the feather, though, we haven&#39;t necessarily corrected for</span>
            <span class="c1"># the overall number of counts in the measurement.</span>
            <span class="c1"># Z = X/Y</span>
            <span class="c1"># var Z = ( (var X / X)**2 + (var Y / Y)**2 ) * Z**2</span>
            <span class="c1">#       = (1/X + 1/Y) * (X/Y)**2</span>
            <span class="c1">#       = (Y + X) * X/Y**3</span>
            <span class="c1">#    dZ = sqrt( (Y+X)*X/Y**3) = sqrt((Y+X)*(X/Y))/Y</span>
            <span class="n">R</span> <span class="o">=</span> <span class="p">(</span><span class="n">Irefl</span> <span class="o">-</span> <span class="n">Iback</span><span class="p">)</span> <span class="o">/</span> <span class="n">Ibeam</span>
            <span class="n">dR</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">((</span><span class="n">Irefl</span> <span class="o">+</span> <span class="n">Iback</span> <span class="o">+</span> <span class="n">Ibeam</span><span class="p">)</span> <span class="o">*</span> <span class="p">(</span><span class="n">Irefl</span> <span class="o">/</span> <span class="n">Ibeam</span><span class="p">))</span> <span class="o">/</span> <span class="n">Ibeam</span>
            <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">dR</span><span class="p">)</span><span class="o">.</span><span class="n">any</span><span class="p">()</span> <span class="ow">or</span> <span class="p">(</span><span class="n">dR</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">any</span><span class="p">()</span> <span class="ow">or</span> <span class="p">(</span><span class="n">R</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">any</span><span class="p">():</span>
                <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Ibeam </span><span class="si">%s</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="n">Ibeam</span><span class="p">)</span>
                <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Irefl </span><span class="si">%s</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="n">Irefl</span><span class="p">)</span>
                <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Iback </span><span class="si">%s</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="n">Iback</span><span class="p">)</span>
                <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;R </span><span class="si">%s</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="n">R</span><span class="p">)</span>
                <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;dR </span><span class="si">%s</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="n">dR</span><span class="p">)</span>
                <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span><span class="s2">&quot;Should not be able to get here!!&quot;</span><span class="p">)</span>
            <span class="c1"># dR[Irefl==0] == 1./Ibeam[Irefl==0]</span>
            <span class="c1"># print(&quot;median %s&quot;%np.median(dR/R))</span>

            <span class="k">if</span> <span class="ow">not</span> <span class="n">normalize</span><span class="p">:</span>
                <span class="c1"># Ci = 1./max(R)</span>
                <span class="n">R</span><span class="p">,</span> <span class="n">dR</span> <span class="o">=</span> <span class="n">R</span> <span class="o">*</span> <span class="n">Ci</span><span class="p">,</span> <span class="n">dR</span> <span class="o">*</span> <span class="n">Ci</span>
                <span class="n">probe</span><span class="o">.</span><span class="n">background</span><span class="o">.</span><span class="n">value</span> <span class="o">*=</span> <span class="n">Ci</span>
                <span class="n">probe</span><span class="o">.</span><span class="n">intensity</span><span class="o">.</span><span class="n">value</span> <span class="o">=</span> <span class="n">Ci</span>

            <span class="n">probe</span><span class="o">.</span><span class="n">R</span> <span class="o">=</span> <span class="n">R</span>
            <span class="n">probe</span><span class="o">.</span><span class="n">dR</span> <span class="o">=</span> <span class="n">dR</span>
            <span class="n">probes</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">probe</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">Experiment</span><span class="p">(</span><span class="n">sample</span><span class="o">=</span><span class="n">sample</span><span class="p">,</span> <span class="n">probe</span><span class="o">=</span><span class="n">ProbeSet</span><span class="p">(</span><span class="n">probes</span><span class="p">))</span></div>


<div class="viewcode-block" id="Pulsed.resolution">
<a class="viewcode-back" href="../../refl1d.instrument.html#refl1d.instrument.Pulsed.resolution">[docs]</a>
    <span class="k">def</span> <span class="nf">resolution</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">L</span><span class="p">,</span> <span class="n">dL</span><span class="p">,</span> <span class="o">**</span><span class="n">kw</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return the resolution of the measurement.  Needs *T*, *L*, *dL*</span>
<span class="sd">        specified as keywords.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">T</span> <span class="o">=</span> <span class="n">kw</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s2">&quot;T&quot;</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">T</span><span class="p">)</span>
        <span class="k">if</span> <span class="s2">&quot;slits&quot;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">kw</span><span class="p">:</span>
            <span class="n">kw</span><span class="p">[</span><span class="s2">&quot;slits&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">calc_slits</span><span class="p">(</span><span class="n">T</span><span class="o">=</span><span class="n">T</span><span class="p">,</span> <span class="o">**</span><span class="n">kw</span><span class="p">)</span>
        <span class="n">dT</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">calc_dT</span><span class="p">(</span><span class="n">T</span><span class="p">,</span> <span class="o">**</span><span class="n">kw</span><span class="p">)</span>

        <span class="c1"># Compute the FWHM angular divergence in radians</span>
        <span class="c1"># Return the resolution</span>
        <span class="k">return</span> <span class="n">T</span><span class="p">,</span> <span class="n">dT</span><span class="p">,</span> <span class="n">L</span><span class="p">,</span> <span class="n">dL</span></div>


<div class="viewcode-block" id="Pulsed.calc_slits">
<a class="viewcode-back" href="../../refl1d.instrument.html#refl1d.instrument.Pulsed.calc_slits">[docs]</a>
    <span class="k">def</span> <span class="nf">calc_slits</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">**</span><span class="n">kw</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Determines slit openings from measurement pattern.</span>

<span class="sd">        If slits are fixed simply return the same slits for every angle,</span>
<span class="sd">        otherwise use an opening range [Tlo, Thi] and the value of the</span>
<span class="sd">        slits at the start of the opening to define the slits.  Slits</span>
<span class="sd">        below Tlo and above Thi can be specified separately.</span>

<span class="sd">        *T*              incident angle</span>
<span class="sd">        *Tlo*, *Thi*     angle range over which slits are opening</span>
<span class="sd">        *slits_at_Tlo*   openings at the start of the range, or fixed opening</span>
<span class="sd">        *slits_below*, *slits_above*   openings below and above the range</span>

<span class="sd">        Use fixed_slits is available, otherwise use opening slits.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="s2">&quot;T&quot;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">kw</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;calc_slits requires angle T=...&quot;</span><span class="p">)</span>
        <span class="n">T</span> <span class="o">=</span> <span class="n">kw</span><span class="p">[</span><span class="s2">&quot;T&quot;</span><span class="p">]</span>
        <span class="n">Tlo</span> <span class="o">=</span> <span class="n">kw</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;Tlo&quot;</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">Tlo</span><span class="p">)</span>
        <span class="n">Thi</span> <span class="o">=</span> <span class="n">kw</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;Thi&quot;</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">Thi</span><span class="p">)</span>
        <span class="n">fixed_slits</span> <span class="o">=</span> <span class="n">kw</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;fixed_slits&quot;</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">fixed_slits</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">fixed_slits</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">slits_at_Tlo</span> <span class="o">=</span> <span class="n">slits_below</span> <span class="o">=</span> <span class="n">slits_above</span> <span class="o">=</span> <span class="n">fixed_slits</span>
            <span class="n">Tlo</span> <span class="o">=</span> <span class="mi">90</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">slits_at_Tlo</span> <span class="o">=</span> <span class="n">kw</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;slits_at_Tlo&quot;</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">slits_at_Tlo</span><span class="p">)</span>
            <span class="n">slits_below</span> <span class="o">=</span> <span class="n">kw</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;slits_below&quot;</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">slits_below</span><span class="p">)</span>
            <span class="n">slits_above</span> <span class="o">=</span> <span class="n">kw</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;slits_above&quot;</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">slits_above</span><span class="p">)</span>

        <span class="c1"># Otherwise we are using opening slits</span>
        <span class="k">if</span> <span class="n">Tlo</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">or</span> <span class="n">slits_at_Tlo</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;Resolution calculation requires Tlo and slits_at_Tlo&quot;</span><span class="p">)</span>
        <span class="n">slits</span> <span class="o">=</span> <span class="n">slit_widths</span><span class="p">(</span>
            <span class="n">T</span><span class="o">=</span><span class="n">T</span><span class="p">,</span> <span class="n">slits_at_Tlo</span><span class="o">=</span><span class="n">slits_at_Tlo</span><span class="p">,</span> <span class="n">Tlo</span><span class="o">=</span><span class="n">Tlo</span><span class="p">,</span> <span class="n">Thi</span><span class="o">=</span><span class="n">Thi</span><span class="p">,</span> <span class="n">slits_below</span><span class="o">=</span><span class="n">slits_below</span><span class="p">,</span> <span class="n">slits_above</span><span class="o">=</span><span class="n">slits_above</span>
        <span class="p">)</span>
        <span class="k">return</span> <span class="n">slits</span></div>


<div class="viewcode-block" id="Pulsed.calc_dT">
<a class="viewcode-back" href="../../refl1d.instrument.html#refl1d.instrument.Pulsed.calc_dT">[docs]</a>
    <span class="k">def</span> <span class="nf">calc_dT</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">T</span><span class="p">,</span> <span class="n">slits</span><span class="p">,</span> <span class="o">**</span><span class="n">kw</span><span class="p">):</span>
        <span class="n">d_s1</span> <span class="o">=</span> <span class="n">kw</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;d_s1&quot;</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">d_s1</span><span class="p">)</span>
        <span class="n">d_s2</span> <span class="o">=</span> <span class="n">kw</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;d_s2&quot;</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">d_s2</span><span class="p">)</span>
        <span class="n">sample_width</span> <span class="o">=</span> <span class="n">kw</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;sample_width&quot;</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">sample_width</span><span class="p">)</span>
        <span class="n">sample_broadening</span> <span class="o">=</span> <span class="n">kw</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;sample_broadening&quot;</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">sample_broadening</span><span class="p">)</span>
        <span class="n">dT</span> <span class="o">=</span> <span class="n">divergence</span><span class="p">(</span>
            <span class="n">T</span><span class="o">=</span><span class="n">T</span><span class="p">,</span> <span class="n">slits</span><span class="o">=</span><span class="n">slits</span><span class="p">,</span> <span class="n">distance</span><span class="o">=</span><span class="p">(</span><span class="n">d_s1</span><span class="p">,</span> <span class="n">d_s2</span><span class="p">),</span> <span class="n">sample_width</span><span class="o">=</span><span class="n">sample_width</span><span class="p">,</span> <span class="n">sample_broadening</span><span class="o">=</span><span class="n">sample_broadening</span>
        <span class="p">)</span>

        <span class="k">return</span> <span class="n">dT</span></div>


    <span class="k">def</span> <span class="fm">__str__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">msg</span> <span class="o">=</span> <span class="s2">&quot;&quot;&quot;</span><span class="se">\</span>
<span class="s2">== Instrument </span><span class="si">%(name)s</span><span class="s2"> ==</span>
<span class="s2">radiation = </span><span class="si">%(radiation)s</span><span class="s2"> in </span><span class="si">%(L_min)g</span><span class="s2"> to </span><span class="si">%(L_max)g</span><span class="s2"> Angstrom with </span><span class="si">%(dLpercent)g%%</span><span class="s2"> resolution</span>
<span class="s2">slit distances = </span><span class="si">%(d_s1)g</span><span class="s2"> mm and </span><span class="si">%(d_s2)g</span><span class="s2"> mm</span>
<span class="s2">slit openings = </span><span class="si">%(slits)s</span><span class="s2"> mm</span>
<span class="s2">sample width = </span><span class="si">%(sample_width)g</span><span class="s2"> mm</span>
<span class="s2">sample broadening = </span><span class="si">%(sample_broadening)g</span><span class="s2"> degrees FWHM</span>
<span class="s2">&quot;&quot;&quot;</span> <span class="o">%</span> <span class="nb">dict</span><span class="p">(</span>
            <span class="n">name</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">instrument</span><span class="p">,</span>
            <span class="n">L_min</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">wavelength</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span>
            <span class="n">L_max</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">wavelength</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span>
            <span class="n">dLpercent</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">dLoL</span> <span class="o">*</span> <span class="mi">100</span><span class="p">,</span>
            <span class="n">d_s1</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">d_s1</span><span class="p">,</span>
            <span class="n">d_s2</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">d_s2</span><span class="p">,</span>
            <span class="n">slits</span><span class="o">=</span><span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">slits</span><span class="p">),</span>
            <span class="n">sample_width</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">sample_width</span><span class="p">,</span>
            <span class="n">sample_broadening</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">sample_broadening</span><span class="p">,</span>
            <span class="n">radiation</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">radiation</span><span class="p">,</span>
        <span class="p">)</span>
        <span class="k">return</span> <span class="n">msg</span>

<div class="viewcode-block" id="Pulsed.defaults">
<a class="viewcode-back" href="../../refl1d.instrument.html#refl1d.instrument.Pulsed.defaults">[docs]</a>
    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">defaults</span><span class="p">(</span><span class="bp">cls</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return default instrument properties as a printable string.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">msg</span> <span class="o">=</span> <span class="s2">&quot;&quot;&quot;</span><span class="se">\</span>
<span class="s2">== Instrument class </span><span class="si">%(name)s</span><span class="s2"> ==</span>
<span class="s2">radiation = </span><span class="si">%(radiation)s</span><span class="s2"> in </span><span class="si">%(L_min)g</span><span class="s2"> to </span><span class="si">%(L_max)g</span><span class="s2"> Angstrom with </span><span class="si">%(dLpercent)g%%</span><span class="s2"> resolution</span>
<span class="s2">slit distances = </span><span class="si">%(d_s1)g</span><span class="s2"> mm and </span><span class="si">%(d_s2)g</span><span class="s2"> mm</span>
<span class="s2">&quot;&quot;&quot;</span> <span class="o">%</span> <span class="nb">dict</span><span class="p">(</span>
            <span class="n">name</span><span class="o">=</span><span class="bp">cls</span><span class="o">.</span><span class="n">instrument</span><span class="p">,</span>
            <span class="n">L_min</span><span class="o">=</span><span class="bp">cls</span><span class="o">.</span><span class="n">wavelength</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span>
            <span class="n">L_max</span><span class="o">=</span><span class="bp">cls</span><span class="o">.</span><span class="n">wavelength</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span>
            <span class="n">dLpercent</span><span class="o">=</span><span class="bp">cls</span><span class="o">.</span><span class="n">dLoL</span> <span class="o">*</span> <span class="mi">100</span><span class="p">,</span>
            <span class="n">d_s1</span><span class="o">=</span><span class="bp">cls</span><span class="o">.</span><span class="n">d_s1</span><span class="p">,</span>
            <span class="n">d_s2</span><span class="o">=</span><span class="bp">cls</span><span class="o">.</span><span class="n">d_s2</span><span class="p">,</span>
            <span class="n">radiation</span><span class="o">=</span><span class="bp">cls</span><span class="o">.</span><span class="n">radiation</span><span class="p">,</span>
        <span class="p">)</span>
        <span class="k">return</span> <span class="n">msg</span></div>
</div>



<span class="n">_</span> <span class="o">=</span> <span class="s1">&#39;&#39;&#39;</span>
<span class="s1">class GenericMonochromatic(Monochromatic):</span>
<span class="s1">    def load(self, filename, **kw):</span>
<span class="s1">        &quot;&quot;&quot;</span>
<span class="s1">        Load the data, returning the associated probe.  This probe will</span>
<span class="s1">        contain Q, angle, wavelength, measured reflectivity and the</span>
<span class="s1">        associated uncertainties.</span>

<span class="s1">        You can override instrument parameters using key=value.  In</span>
<span class="s1">        particular, slit settings *slits_at_Tlo*, *Tlo*, *Thi*,</span>
<span class="s1">        and *slits_below*, and *slits_above* are used to define the</span>
<span class="s1">        angular divergence.</span>

<span class="s1">        .. Note::</span>
<span class="s1">             This function ignores any resolution information stored in</span>
<span class="s1">             the file, such as dQ, dT or dL columns, and instead uses the</span>
<span class="s1">             defined instrument parameters to calculate the resolution.</span>

<span class="s1">        &quot;&quot;&quot;</span>
<span class="s1">        # Load the data</span>
<span class="s1">        data = np.loadtxt(filename).T</span>
<span class="s1">        if data.shape[0] == 2:</span>
<span class="s1">            Q, R = data</span>
<span class="s1">            dR = None</span>
<span class="s1">        elif data.shape[0] == 3:</span>
<span class="s1">            Q, R, dR = data</span>
<span class="s1">        elif data.shape[0] == 4:</span>
<span class="s1">            Q, dQ, R, dR = data</span>
<span class="s1">        elif data.shape[0] == 5:</span>
<span class="s1">            Q, dQ, R, dR, L = data</span>
<span class="s1">        if &quot;Q&quot; not in kw: kw[&quot;Q&quot;] = Q</span>
<span class="s1">        T, dT, L, dL = self.resolution(**kw)</span>
<span class="s1">        kw.update(dict(T=T, dT=dT, L=L, dL=dL, data=(R, dR),</span>
<span class="s1">                       radiation=self.radiation))</span>
<span class="s1">        return make_probe(**kw)</span>

<span class="s1">class GenericPulsed(Pulsed):</span>
<span class="s1">    def load(self, filename, **kw):</span>
<span class="s1">        &quot;&quot;&quot;</span>
<span class="s1">        Load the data, returning the associated probe.  This probe will</span>
<span class="s1">        contain Q, angle, wavelength, measured reflectivity and the</span>
<span class="s1">        associated uncertainties.</span>

<span class="s1">        You can override instrument parameters using key=value.</span>
<span class="s1">        In particular, slit settings *slits* and *T* define the</span>
<span class="s1">        angular divergence.</span>
<span class="s1">        &quot;&quot;&quot;</span>
<span class="s1">        # Load the data</span>
<span class="s1">        data = np.loadtxt(filename).T</span>
<span class="s1">        Q, dQ, R, dR, L = data</span>
<span class="s1">        dL = binwidths(L)</span>
<span class="s1">        T = kw.pop(&#39;T&#39;, QL2T(Q, L))</span>
<span class="s1">        T, dT, L, dL = self.resolution(L=L, dL=dL, T=T, **kw)</span>
<span class="s1">        return make_probe(T=T, dT=dT, L=L, dL=dL, data=(R, dR),</span>
<span class="s1">                          radiation=self.radiation, **kw)</span>
<span class="s1">&#39;&#39;&#39;</span>
</pre></div>

      </div>
      <div class="bottomnav" role="navigation" aria-label="Bottom">
      
        <p>
        <a class="uplink" href="../../index.html">Contents</a>
        </p>

      </div>

    <div class="footer" role="contentinfo">
      Created using <a href="https://www.sphinx-doc.org/">Sphinx</a> 8.1.3.
    </div>
  </body>
</html>